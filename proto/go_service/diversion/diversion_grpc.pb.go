// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: proto/go_service/diversion/diversion.proto

package diversion

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AbtestWhiteUser_QueryAbtestWhiteUserDetail_FullMethodName = "/diversion.abtestWhiteUser/QueryAbtestWhiteUserDetail"
	AbtestWhiteUser_QueryAbtestWhiteUserList_FullMethodName   = "/diversion.abtestWhiteUser/QueryAbtestWhiteUserList"
)

// AbtestWhiteUserClient is the client API for AbtestWhiteUser service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AbtestWhiteUserClient interface {
	// -----------------------实验配置白名单表-----------------------
	QueryAbtestWhiteUserDetail(ctx context.Context, in *AbtestWhiteUserFilter, opts ...grpc.CallOption) (*AbtestWhiteUser, error)
	QueryAbtestWhiteUserList(ctx context.Context, in *AbtestWhiteUserFilter, opts ...grpc.CallOption) (*AbtestWhiteUserList, error)
}

type abtestWhiteUserClient struct {
	cc grpc.ClientConnInterface
}

func NewAbtestWhiteUserClient(cc grpc.ClientConnInterface) AbtestWhiteUserClient {
	return &abtestWhiteUserClient{cc}
}

func (c *abtestWhiteUserClient) QueryAbtestWhiteUserDetail(ctx context.Context, in *AbtestWhiteUserFilter, opts ...grpc.CallOption) (*AbtestWhiteUser, error) {
	out := new(AbtestWhiteUser)
	err := c.cc.Invoke(ctx, AbtestWhiteUser_QueryAbtestWhiteUserDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestWhiteUserClient) QueryAbtestWhiteUserList(ctx context.Context, in *AbtestWhiteUserFilter, opts ...grpc.CallOption) (*AbtestWhiteUserList, error) {
	out := new(AbtestWhiteUserList)
	err := c.cc.Invoke(ctx, AbtestWhiteUser_QueryAbtestWhiteUserList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AbtestWhiteUserServer is the server API for AbtestWhiteUser service.
// All implementations must embed UnimplementedAbtestWhiteUserServer
// for forward compatibility
type AbtestWhiteUserServer interface {
	// -----------------------实验配置白名单表-----------------------
	QueryAbtestWhiteUserDetail(context.Context, *AbtestWhiteUserFilter) (*AbtestWhiteUser, error)
	QueryAbtestWhiteUserList(context.Context, *AbtestWhiteUserFilter) (*AbtestWhiteUserList, error)
	mustEmbedUnimplementedAbtestWhiteUserServer()
}

// UnimplementedAbtestWhiteUserServer must be embedded to have forward compatible implementations.
type UnimplementedAbtestWhiteUserServer struct {
}

func (UnimplementedAbtestWhiteUserServer) QueryAbtestWhiteUserDetail(context.Context, *AbtestWhiteUserFilter) (*AbtestWhiteUser, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestWhiteUserDetail not implemented")
}
func (UnimplementedAbtestWhiteUserServer) QueryAbtestWhiteUserList(context.Context, *AbtestWhiteUserFilter) (*AbtestWhiteUserList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestWhiteUserList not implemented")
}
func (UnimplementedAbtestWhiteUserServer) mustEmbedUnimplementedAbtestWhiteUserServer() {}

// UnsafeAbtestWhiteUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AbtestWhiteUserServer will
// result in compilation errors.
type UnsafeAbtestWhiteUserServer interface {
	mustEmbedUnimplementedAbtestWhiteUserServer()
}

func RegisterAbtestWhiteUserServer(s grpc.ServiceRegistrar, srv AbtestWhiteUserServer) {
	s.RegisterService(&AbtestWhiteUser_ServiceDesc, srv)
}

func _AbtestWhiteUser_QueryAbtestWhiteUserDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestWhiteUserFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestWhiteUserServer).QueryAbtestWhiteUserDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestWhiteUser_QueryAbtestWhiteUserDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestWhiteUserServer).QueryAbtestWhiteUserDetail(ctx, req.(*AbtestWhiteUserFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestWhiteUser_QueryAbtestWhiteUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestWhiteUserFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestWhiteUserServer).QueryAbtestWhiteUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestWhiteUser_QueryAbtestWhiteUserList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestWhiteUserServer).QueryAbtestWhiteUserList(ctx, req.(*AbtestWhiteUserFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AbtestWhiteUser_ServiceDesc is the grpc.ServiceDesc for AbtestWhiteUser service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AbtestWhiteUser_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.abtestWhiteUser",
	HandlerType: (*AbtestWhiteUserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryAbtestWhiteUserDetail",
			Handler:    _AbtestWhiteUser_QueryAbtestWhiteUserDetail_Handler,
		},
		{
			MethodName: "QueryAbtestWhiteUserList",
			Handler:    _AbtestWhiteUser_QueryAbtestWhiteUserList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AbtestExperimentGroup_QueryAbtestExperimentGroupDetail_FullMethodName = "/diversion.abtestExperimentGroup/QueryAbtestExperimentGroupDetail"
	AbtestExperimentGroup_QueryAbtestExperimentGroupList_FullMethodName   = "/diversion.abtestExperimentGroup/QueryAbtestExperimentGroupList"
)

// AbtestExperimentGroupClient is the client API for AbtestExperimentGroup service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AbtestExperimentGroupClient interface {
	// -----------------------实验配置分组表-----------------------
	QueryAbtestExperimentGroupDetail(ctx context.Context, in *AbtestExperimentGroupFilter, opts ...grpc.CallOption) (*AbtestExperimentGroup, error)
	QueryAbtestExperimentGroupList(ctx context.Context, in *AbtestExperimentGroupFilter, opts ...grpc.CallOption) (*AbtestExperimentGroupList, error)
}

type abtestExperimentGroupClient struct {
	cc grpc.ClientConnInterface
}

func NewAbtestExperimentGroupClient(cc grpc.ClientConnInterface) AbtestExperimentGroupClient {
	return &abtestExperimentGroupClient{cc}
}

func (c *abtestExperimentGroupClient) QueryAbtestExperimentGroupDetail(ctx context.Context, in *AbtestExperimentGroupFilter, opts ...grpc.CallOption) (*AbtestExperimentGroup, error) {
	out := new(AbtestExperimentGroup)
	err := c.cc.Invoke(ctx, AbtestExperimentGroup_QueryAbtestExperimentGroupDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestExperimentGroupClient) QueryAbtestExperimentGroupList(ctx context.Context, in *AbtestExperimentGroupFilter, opts ...grpc.CallOption) (*AbtestExperimentGroupList, error) {
	out := new(AbtestExperimentGroupList)
	err := c.cc.Invoke(ctx, AbtestExperimentGroup_QueryAbtestExperimentGroupList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AbtestExperimentGroupServer is the server API for AbtestExperimentGroup service.
// All implementations must embed UnimplementedAbtestExperimentGroupServer
// for forward compatibility
type AbtestExperimentGroupServer interface {
	// -----------------------实验配置分组表-----------------------
	QueryAbtestExperimentGroupDetail(context.Context, *AbtestExperimentGroupFilter) (*AbtestExperimentGroup, error)
	QueryAbtestExperimentGroupList(context.Context, *AbtestExperimentGroupFilter) (*AbtestExperimentGroupList, error)
	mustEmbedUnimplementedAbtestExperimentGroupServer()
}

// UnimplementedAbtestExperimentGroupServer must be embedded to have forward compatible implementations.
type UnimplementedAbtestExperimentGroupServer struct {
}

func (UnimplementedAbtestExperimentGroupServer) QueryAbtestExperimentGroupDetail(context.Context, *AbtestExperimentGroupFilter) (*AbtestExperimentGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestExperimentGroupDetail not implemented")
}
func (UnimplementedAbtestExperimentGroupServer) QueryAbtestExperimentGroupList(context.Context, *AbtestExperimentGroupFilter) (*AbtestExperimentGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestExperimentGroupList not implemented")
}
func (UnimplementedAbtestExperimentGroupServer) mustEmbedUnimplementedAbtestExperimentGroupServer() {}

// UnsafeAbtestExperimentGroupServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AbtestExperimentGroupServer will
// result in compilation errors.
type UnsafeAbtestExperimentGroupServer interface {
	mustEmbedUnimplementedAbtestExperimentGroupServer()
}

func RegisterAbtestExperimentGroupServer(s grpc.ServiceRegistrar, srv AbtestExperimentGroupServer) {
	s.RegisterService(&AbtestExperimentGroup_ServiceDesc, srv)
}

func _AbtestExperimentGroup_QueryAbtestExperimentGroupDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentGroupFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentGroupServer).QueryAbtestExperimentGroupDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperimentGroup_QueryAbtestExperimentGroupDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentGroupServer).QueryAbtestExperimentGroupDetail(ctx, req.(*AbtestExperimentGroupFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestExperimentGroup_QueryAbtestExperimentGroupList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentGroupFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentGroupServer).QueryAbtestExperimentGroupList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperimentGroup_QueryAbtestExperimentGroupList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentGroupServer).QueryAbtestExperimentGroupList(ctx, req.(*AbtestExperimentGroupFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AbtestExperimentGroup_ServiceDesc is the grpc.ServiceDesc for AbtestExperimentGroup service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AbtestExperimentGroup_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.abtestExperimentGroup",
	HandlerType: (*AbtestExperimentGroupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryAbtestExperimentGroupDetail",
			Handler:    _AbtestExperimentGroup_QueryAbtestExperimentGroupDetail_Handler,
		},
		{
			MethodName: "QueryAbtestExperimentGroupList",
			Handler:    _AbtestExperimentGroup_QueryAbtestExperimentGroupList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AbtestExperiment_QueryAbtestExperimentDetail_FullMethodName = "/diversion.abtestExperiment/QueryAbtestExperimentDetail"
	AbtestExperiment_QueryAbtestExperimentList_FullMethodName   = "/diversion.abtestExperiment/QueryAbtestExperimentList"
)

// AbtestExperimentClient is the client API for AbtestExperiment service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AbtestExperimentClient interface {
	// -----------------------实验配置主表-----------------------
	QueryAbtestExperimentDetail(ctx context.Context, in *AbtestExperimentFilter, opts ...grpc.CallOption) (*AbtestExperiment, error)
	QueryAbtestExperimentList(ctx context.Context, in *AbtestExperimentFilter, opts ...grpc.CallOption) (*AbtestExperimentList, error)
}

type abtestExperimentClient struct {
	cc grpc.ClientConnInterface
}

func NewAbtestExperimentClient(cc grpc.ClientConnInterface) AbtestExperimentClient {
	return &abtestExperimentClient{cc}
}

func (c *abtestExperimentClient) QueryAbtestExperimentDetail(ctx context.Context, in *AbtestExperimentFilter, opts ...grpc.CallOption) (*AbtestExperiment, error) {
	out := new(AbtestExperiment)
	err := c.cc.Invoke(ctx, AbtestExperiment_QueryAbtestExperimentDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestExperimentClient) QueryAbtestExperimentList(ctx context.Context, in *AbtestExperimentFilter, opts ...grpc.CallOption) (*AbtestExperimentList, error) {
	out := new(AbtestExperimentList)
	err := c.cc.Invoke(ctx, AbtestExperiment_QueryAbtestExperimentList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AbtestExperimentServer is the server API for AbtestExperiment service.
// All implementations must embed UnimplementedAbtestExperimentServer
// for forward compatibility
type AbtestExperimentServer interface {
	// -----------------------实验配置主表-----------------------
	QueryAbtestExperimentDetail(context.Context, *AbtestExperimentFilter) (*AbtestExperiment, error)
	QueryAbtestExperimentList(context.Context, *AbtestExperimentFilter) (*AbtestExperimentList, error)
	mustEmbedUnimplementedAbtestExperimentServer()
}

// UnimplementedAbtestExperimentServer must be embedded to have forward compatible implementations.
type UnimplementedAbtestExperimentServer struct {
}

func (UnimplementedAbtestExperimentServer) QueryAbtestExperimentDetail(context.Context, *AbtestExperimentFilter) (*AbtestExperiment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestExperimentDetail not implemented")
}
func (UnimplementedAbtestExperimentServer) QueryAbtestExperimentList(context.Context, *AbtestExperimentFilter) (*AbtestExperimentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestExperimentList not implemented")
}
func (UnimplementedAbtestExperimentServer) mustEmbedUnimplementedAbtestExperimentServer() {}

// UnsafeAbtestExperimentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AbtestExperimentServer will
// result in compilation errors.
type UnsafeAbtestExperimentServer interface {
	mustEmbedUnimplementedAbtestExperimentServer()
}

func RegisterAbtestExperimentServer(s grpc.ServiceRegistrar, srv AbtestExperimentServer) {
	s.RegisterService(&AbtestExperiment_ServiceDesc, srv)
}

func _AbtestExperiment_QueryAbtestExperimentDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentServer).QueryAbtestExperimentDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperiment_QueryAbtestExperimentDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentServer).QueryAbtestExperimentDetail(ctx, req.(*AbtestExperimentFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestExperiment_QueryAbtestExperimentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentServer).QueryAbtestExperimentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperiment_QueryAbtestExperimentList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentServer).QueryAbtestExperimentList(ctx, req.(*AbtestExperimentFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AbtestExperiment_ServiceDesc is the grpc.ServiceDesc for AbtestExperiment service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AbtestExperiment_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.abtestExperiment",
	HandlerType: (*AbtestExperimentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryAbtestExperimentDetail",
			Handler:    _AbtestExperiment_QueryAbtestExperimentDetail_Handler,
		},
		{
			MethodName: "QueryAbtestExperimentList",
			Handler:    _AbtestExperiment_QueryAbtestExperimentList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	GlobalSecret_QueryGlobalSecretDetail_FullMethodName = "/diversion.globalSecret/QueryGlobalSecretDetail"
	GlobalSecret_QueryGlobalSecretList_FullMethodName   = "/diversion.globalSecret/QueryGlobalSecretList"
)

// GlobalSecretClient is the client API for GlobalSecret service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalSecretClient interface {
	// -----------------------globalSecret-----------------------
	QueryGlobalSecretDetail(ctx context.Context, in *GlobalSecretFilter, opts ...grpc.CallOption) (*GlobalSecret, error)
	QueryGlobalSecretList(ctx context.Context, in *GlobalSecretFilter, opts ...grpc.CallOption) (*GlobalSecretList, error)
}

type globalSecretClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalSecretClient(cc grpc.ClientConnInterface) GlobalSecretClient {
	return &globalSecretClient{cc}
}

func (c *globalSecretClient) QueryGlobalSecretDetail(ctx context.Context, in *GlobalSecretFilter, opts ...grpc.CallOption) (*GlobalSecret, error) {
	out := new(GlobalSecret)
	err := c.cc.Invoke(ctx, GlobalSecret_QueryGlobalSecretDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalSecretClient) QueryGlobalSecretList(ctx context.Context, in *GlobalSecretFilter, opts ...grpc.CallOption) (*GlobalSecretList, error) {
	out := new(GlobalSecretList)
	err := c.cc.Invoke(ctx, GlobalSecret_QueryGlobalSecretList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalSecretServer is the server API for GlobalSecret service.
// All implementations must embed UnimplementedGlobalSecretServer
// for forward compatibility
type GlobalSecretServer interface {
	// -----------------------globalSecret-----------------------
	QueryGlobalSecretDetail(context.Context, *GlobalSecretFilter) (*GlobalSecret, error)
	QueryGlobalSecretList(context.Context, *GlobalSecretFilter) (*GlobalSecretList, error)
	mustEmbedUnimplementedGlobalSecretServer()
}

// UnimplementedGlobalSecretServer must be embedded to have forward compatible implementations.
type UnimplementedGlobalSecretServer struct {
}

func (UnimplementedGlobalSecretServer) QueryGlobalSecretDetail(context.Context, *GlobalSecretFilter) (*GlobalSecret, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGlobalSecretDetail not implemented")
}
func (UnimplementedGlobalSecretServer) QueryGlobalSecretList(context.Context, *GlobalSecretFilter) (*GlobalSecretList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGlobalSecretList not implemented")
}
func (UnimplementedGlobalSecretServer) mustEmbedUnimplementedGlobalSecretServer() {}

// UnsafeGlobalSecretServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalSecretServer will
// result in compilation errors.
type UnsafeGlobalSecretServer interface {
	mustEmbedUnimplementedGlobalSecretServer()
}

func RegisterGlobalSecretServer(s grpc.ServiceRegistrar, srv GlobalSecretServer) {
	s.RegisterService(&GlobalSecret_ServiceDesc, srv)
}

func _GlobalSecret_QueryGlobalSecretDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobalSecretFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalSecretServer).QueryGlobalSecretDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalSecret_QueryGlobalSecretDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalSecretServer).QueryGlobalSecretDetail(ctx, req.(*GlobalSecretFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalSecret_QueryGlobalSecretList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobalSecretFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalSecretServer).QueryGlobalSecretList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalSecret_QueryGlobalSecretList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalSecretServer).QueryGlobalSecretList(ctx, req.(*GlobalSecretFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalSecret_ServiceDesc is the grpc.ServiceDesc for GlobalSecret service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalSecret_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.globalSecret",
	HandlerType: (*GlobalSecretServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryGlobalSecretDetail",
			Handler:    _GlobalSecret_QueryGlobalSecretDetail_Handler,
		},
		{
			MethodName: "QueryGlobalSecretList",
			Handler:    _GlobalSecret_QueryGlobalSecretList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AbtestUserGroup_QueryAbtestUserGroupDetail_FullMethodName = "/diversion.abtestUserGroup/QueryAbtestUserGroupDetail"
	AbtestUserGroup_QueryAbtestUserGroupList_FullMethodName   = "/diversion.abtestUserGroup/QueryAbtestUserGroupList"
)

// AbtestUserGroupClient is the client API for AbtestUserGroup service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AbtestUserGroupClient interface {
	// -----------------------abtestUserGroup-----------------------
	QueryAbtestUserGroupDetail(ctx context.Context, in *AbtestUserGroupFilter, opts ...grpc.CallOption) (*AbtestUserGroup, error)
	QueryAbtestUserGroupList(ctx context.Context, in *AbtestUserGroupFilter, opts ...grpc.CallOption) (*AbtestUserGroupList, error)
}

type abtestUserGroupClient struct {
	cc grpc.ClientConnInterface
}

func NewAbtestUserGroupClient(cc grpc.ClientConnInterface) AbtestUserGroupClient {
	return &abtestUserGroupClient{cc}
}

func (c *abtestUserGroupClient) QueryAbtestUserGroupDetail(ctx context.Context, in *AbtestUserGroupFilter, opts ...grpc.CallOption) (*AbtestUserGroup, error) {
	out := new(AbtestUserGroup)
	err := c.cc.Invoke(ctx, AbtestUserGroup_QueryAbtestUserGroupDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestUserGroupClient) QueryAbtestUserGroupList(ctx context.Context, in *AbtestUserGroupFilter, opts ...grpc.CallOption) (*AbtestUserGroupList, error) {
	out := new(AbtestUserGroupList)
	err := c.cc.Invoke(ctx, AbtestUserGroup_QueryAbtestUserGroupList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AbtestUserGroupServer is the server API for AbtestUserGroup service.
// All implementations must embed UnimplementedAbtestUserGroupServer
// for forward compatibility
type AbtestUserGroupServer interface {
	// -----------------------abtestUserGroup-----------------------
	QueryAbtestUserGroupDetail(context.Context, *AbtestUserGroupFilter) (*AbtestUserGroup, error)
	QueryAbtestUserGroupList(context.Context, *AbtestUserGroupFilter) (*AbtestUserGroupList, error)
	mustEmbedUnimplementedAbtestUserGroupServer()
}

// UnimplementedAbtestUserGroupServer must be embedded to have forward compatible implementations.
type UnimplementedAbtestUserGroupServer struct {
}

func (UnimplementedAbtestUserGroupServer) QueryAbtestUserGroupDetail(context.Context, *AbtestUserGroupFilter) (*AbtestUserGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestUserGroupDetail not implemented")
}
func (UnimplementedAbtestUserGroupServer) QueryAbtestUserGroupList(context.Context, *AbtestUserGroupFilter) (*AbtestUserGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestUserGroupList not implemented")
}
func (UnimplementedAbtestUserGroupServer) mustEmbedUnimplementedAbtestUserGroupServer() {}

// UnsafeAbtestUserGroupServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AbtestUserGroupServer will
// result in compilation errors.
type UnsafeAbtestUserGroupServer interface {
	mustEmbedUnimplementedAbtestUserGroupServer()
}

func RegisterAbtestUserGroupServer(s grpc.ServiceRegistrar, srv AbtestUserGroupServer) {
	s.RegisterService(&AbtestUserGroup_ServiceDesc, srv)
}

func _AbtestUserGroup_QueryAbtestUserGroupDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestUserGroupFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestUserGroupServer).QueryAbtestUserGroupDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestUserGroup_QueryAbtestUserGroupDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestUserGroupServer).QueryAbtestUserGroupDetail(ctx, req.(*AbtestUserGroupFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestUserGroup_QueryAbtestUserGroupList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestUserGroupFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestUserGroupServer).QueryAbtestUserGroupList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestUserGroup_QueryAbtestUserGroupList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestUserGroupServer).QueryAbtestUserGroupList(ctx, req.(*AbtestUserGroupFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AbtestUserGroup_ServiceDesc is the grpc.ServiceDesc for AbtestUserGroup service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AbtestUserGroup_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.abtestUserGroup",
	HandlerType: (*AbtestUserGroupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryAbtestUserGroupDetail",
			Handler:    _AbtestUserGroup_QueryAbtestUserGroupDetail_Handler,
		},
		{
			MethodName: "QueryAbtestUserGroupList",
			Handler:    _AbtestUserGroup_QueryAbtestUserGroupList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AbtestExperimentResult_QueryAbtestExperimentResultDetail_FullMethodName = "/diversion.abtestExperimentResult/QueryAbtestExperimentResultDetail"
	AbtestExperimentResult_QueryAbtestExperimentResultList_FullMethodName   = "/diversion.abtestExperimentResult/QueryAbtestExperimentResultList"
	AbtestExperimentResult_QueryAbtestExperimentResultCount_FullMethodName  = "/diversion.abtestExperimentResult/QueryAbtestExperimentResultCount"
	AbtestExperimentResult_CreateAbtestExperimentResult_FullMethodName      = "/diversion.abtestExperimentResult/CreateAbtestExperimentResult"
)

// AbtestExperimentResultClient is the client API for AbtestExperimentResult service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AbtestExperimentResultClient interface {
	// -----------------------abtestExperimentResult-----------------------
	QueryAbtestExperimentResultDetail(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*AbtestExperimentResult, error)
	QueryAbtestExperimentResultList(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*AbtestExperimentResultList, error)
	QueryAbtestExperimentResultCount(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*AbtestExperimentResultCount, error)
	CreateAbtestExperimentResult(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*CreateAbtestExperimentResultResp, error)
}

type abtestExperimentResultClient struct {
	cc grpc.ClientConnInterface
}

func NewAbtestExperimentResultClient(cc grpc.ClientConnInterface) AbtestExperimentResultClient {
	return &abtestExperimentResultClient{cc}
}

func (c *abtestExperimentResultClient) QueryAbtestExperimentResultDetail(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*AbtestExperimentResult, error) {
	out := new(AbtestExperimentResult)
	err := c.cc.Invoke(ctx, AbtestExperimentResult_QueryAbtestExperimentResultDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestExperimentResultClient) QueryAbtestExperimentResultList(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*AbtestExperimentResultList, error) {
	out := new(AbtestExperimentResultList)
	err := c.cc.Invoke(ctx, AbtestExperimentResult_QueryAbtestExperimentResultList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestExperimentResultClient) QueryAbtestExperimentResultCount(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*AbtestExperimentResultCount, error) {
	out := new(AbtestExperimentResultCount)
	err := c.cc.Invoke(ctx, AbtestExperimentResult_QueryAbtestExperimentResultCount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestExperimentResultClient) CreateAbtestExperimentResult(ctx context.Context, in *AbtestExperimentResultFilter, opts ...grpc.CallOption) (*CreateAbtestExperimentResultResp, error) {
	out := new(CreateAbtestExperimentResultResp)
	err := c.cc.Invoke(ctx, AbtestExperimentResult_CreateAbtestExperimentResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AbtestExperimentResultServer is the server API for AbtestExperimentResult service.
// All implementations must embed UnimplementedAbtestExperimentResultServer
// for forward compatibility
type AbtestExperimentResultServer interface {
	// -----------------------abtestExperimentResult-----------------------
	QueryAbtestExperimentResultDetail(context.Context, *AbtestExperimentResultFilter) (*AbtestExperimentResult, error)
	QueryAbtestExperimentResultList(context.Context, *AbtestExperimentResultFilter) (*AbtestExperimentResultList, error)
	QueryAbtestExperimentResultCount(context.Context, *AbtestExperimentResultFilter) (*AbtestExperimentResultCount, error)
	CreateAbtestExperimentResult(context.Context, *AbtestExperimentResultFilter) (*CreateAbtestExperimentResultResp, error)
	mustEmbedUnimplementedAbtestExperimentResultServer()
}

// UnimplementedAbtestExperimentResultServer must be embedded to have forward compatible implementations.
type UnimplementedAbtestExperimentResultServer struct {
}

func (UnimplementedAbtestExperimentResultServer) QueryAbtestExperimentResultDetail(context.Context, *AbtestExperimentResultFilter) (*AbtestExperimentResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestExperimentResultDetail not implemented")
}
func (UnimplementedAbtestExperimentResultServer) QueryAbtestExperimentResultList(context.Context, *AbtestExperimentResultFilter) (*AbtestExperimentResultList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestExperimentResultList not implemented")
}
func (UnimplementedAbtestExperimentResultServer) QueryAbtestExperimentResultCount(context.Context, *AbtestExperimentResultFilter) (*AbtestExperimentResultCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestExperimentResultCount not implemented")
}
func (UnimplementedAbtestExperimentResultServer) CreateAbtestExperimentResult(context.Context, *AbtestExperimentResultFilter) (*CreateAbtestExperimentResultResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAbtestExperimentResult not implemented")
}
func (UnimplementedAbtestExperimentResultServer) mustEmbedUnimplementedAbtestExperimentResultServer() {
}

// UnsafeAbtestExperimentResultServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AbtestExperimentResultServer will
// result in compilation errors.
type UnsafeAbtestExperimentResultServer interface {
	mustEmbedUnimplementedAbtestExperimentResultServer()
}

func RegisterAbtestExperimentResultServer(s grpc.ServiceRegistrar, srv AbtestExperimentResultServer) {
	s.RegisterService(&AbtestExperimentResult_ServiceDesc, srv)
}

func _AbtestExperimentResult_QueryAbtestExperimentResultDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentResultFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentResultServer).QueryAbtestExperimentResultDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperimentResult_QueryAbtestExperimentResultDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentResultServer).QueryAbtestExperimentResultDetail(ctx, req.(*AbtestExperimentResultFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestExperimentResult_QueryAbtestExperimentResultList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentResultFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentResultServer).QueryAbtestExperimentResultList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperimentResult_QueryAbtestExperimentResultList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentResultServer).QueryAbtestExperimentResultList(ctx, req.(*AbtestExperimentResultFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestExperimentResult_QueryAbtestExperimentResultCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentResultFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentResultServer).QueryAbtestExperimentResultCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperimentResult_QueryAbtestExperimentResultCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentResultServer).QueryAbtestExperimentResultCount(ctx, req.(*AbtestExperimentResultFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestExperimentResult_CreateAbtestExperimentResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestExperimentResultFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestExperimentResultServer).CreateAbtestExperimentResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestExperimentResult_CreateAbtestExperimentResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestExperimentResultServer).CreateAbtestExperimentResult(ctx, req.(*AbtestExperimentResultFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AbtestExperimentResult_ServiceDesc is the grpc.ServiceDesc for AbtestExperimentResult service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AbtestExperimentResult_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.abtestExperimentResult",
	HandlerType: (*AbtestExperimentResultServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryAbtestExperimentResultDetail",
			Handler:    _AbtestExperimentResult_QueryAbtestExperimentResultDetail_Handler,
		},
		{
			MethodName: "QueryAbtestExperimentResultList",
			Handler:    _AbtestExperimentResult_QueryAbtestExperimentResultList_Handler,
		},
		{
			MethodName: "QueryAbtestExperimentResultCount",
			Handler:    _AbtestExperimentResult_QueryAbtestExperimentResultCount_Handler,
		},
		{
			MethodName: "CreateAbtestExperimentResult",
			Handler:    _AbtestExperimentResult_CreateAbtestExperimentResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AbtestUserGroupConf_QueryAbtestUserGroupConfDetail_FullMethodName = "/diversion.abtestUserGroupConf/QueryAbtestUserGroupConfDetail"
	AbtestUserGroupConf_QueryAbtestUserGroupConfList_FullMethodName   = "/diversion.abtestUserGroupConf/QueryAbtestUserGroupConfList"
)

// AbtestUserGroupConfClient is the client API for AbtestUserGroupConf service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AbtestUserGroupConfClient interface {
	// -----------------------实验用户群配置表-----------------------
	QueryAbtestUserGroupConfDetail(ctx context.Context, in *AbtestUserGroupConfFilter, opts ...grpc.CallOption) (*AbtestUserGroupConf, error)
	QueryAbtestUserGroupConfList(ctx context.Context, in *AbtestUserGroupConfFilter, opts ...grpc.CallOption) (*AbtestUserGroupConfList, error)
}

type abtestUserGroupConfClient struct {
	cc grpc.ClientConnInterface
}

func NewAbtestUserGroupConfClient(cc grpc.ClientConnInterface) AbtestUserGroupConfClient {
	return &abtestUserGroupConfClient{cc}
}

func (c *abtestUserGroupConfClient) QueryAbtestUserGroupConfDetail(ctx context.Context, in *AbtestUserGroupConfFilter, opts ...grpc.CallOption) (*AbtestUserGroupConf, error) {
	out := new(AbtestUserGroupConf)
	err := c.cc.Invoke(ctx, AbtestUserGroupConf_QueryAbtestUserGroupConfDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *abtestUserGroupConfClient) QueryAbtestUserGroupConfList(ctx context.Context, in *AbtestUserGroupConfFilter, opts ...grpc.CallOption) (*AbtestUserGroupConfList, error) {
	out := new(AbtestUserGroupConfList)
	err := c.cc.Invoke(ctx, AbtestUserGroupConf_QueryAbtestUserGroupConfList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AbtestUserGroupConfServer is the server API for AbtestUserGroupConf service.
// All implementations must embed UnimplementedAbtestUserGroupConfServer
// for forward compatibility
type AbtestUserGroupConfServer interface {
	// -----------------------实验用户群配置表-----------------------
	QueryAbtestUserGroupConfDetail(context.Context, *AbtestUserGroupConfFilter) (*AbtestUserGroupConf, error)
	QueryAbtestUserGroupConfList(context.Context, *AbtestUserGroupConfFilter) (*AbtestUserGroupConfList, error)
	mustEmbedUnimplementedAbtestUserGroupConfServer()
}

// UnimplementedAbtestUserGroupConfServer must be embedded to have forward compatible implementations.
type UnimplementedAbtestUserGroupConfServer struct {
}

func (UnimplementedAbtestUserGroupConfServer) QueryAbtestUserGroupConfDetail(context.Context, *AbtestUserGroupConfFilter) (*AbtestUserGroupConf, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestUserGroupConfDetail not implemented")
}
func (UnimplementedAbtestUserGroupConfServer) QueryAbtestUserGroupConfList(context.Context, *AbtestUserGroupConfFilter) (*AbtestUserGroupConfList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAbtestUserGroupConfList not implemented")
}
func (UnimplementedAbtestUserGroupConfServer) mustEmbedUnimplementedAbtestUserGroupConfServer() {}

// UnsafeAbtestUserGroupConfServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AbtestUserGroupConfServer will
// result in compilation errors.
type UnsafeAbtestUserGroupConfServer interface {
	mustEmbedUnimplementedAbtestUserGroupConfServer()
}

func RegisterAbtestUserGroupConfServer(s grpc.ServiceRegistrar, srv AbtestUserGroupConfServer) {
	s.RegisterService(&AbtestUserGroupConf_ServiceDesc, srv)
}

func _AbtestUserGroupConf_QueryAbtestUserGroupConfDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestUserGroupConfFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestUserGroupConfServer).QueryAbtestUserGroupConfDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestUserGroupConf_QueryAbtestUserGroupConfDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestUserGroupConfServer).QueryAbtestUserGroupConfDetail(ctx, req.(*AbtestUserGroupConfFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AbtestUserGroupConf_QueryAbtestUserGroupConfList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbtestUserGroupConfFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AbtestUserGroupConfServer).QueryAbtestUserGroupConfList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AbtestUserGroupConf_QueryAbtestUserGroupConfList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AbtestUserGroupConfServer).QueryAbtestUserGroupConfList(ctx, req.(*AbtestUserGroupConfFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AbtestUserGroupConf_ServiceDesc is the grpc.ServiceDesc for AbtestUserGroupConf service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AbtestUserGroupConf_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.abtestUserGroupConf",
	HandlerType: (*AbtestUserGroupConfServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryAbtestUserGroupConfDetail",
			Handler:    _AbtestUserGroupConf_QueryAbtestUserGroupConfDetail_Handler,
		},
		{
			MethodName: "QueryAbtestUserGroupConfList",
			Handler:    _AbtestUserGroupConf_QueryAbtestUserGroupConfList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	TblUserAlipay_QueryTblUserAlipayDetail_FullMethodName = "/diversion.tblUserAlipay/QueryTblUserAlipayDetail"
	TblUserAlipay_QueryTblUserAlipayList_FullMethodName   = "/diversion.tblUserAlipay/QueryTblUserAlipayList"
)

// TblUserAlipayClient is the client API for TblUserAlipay service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TblUserAlipayClient interface {
	// -----------------------COLUMNAR=1 用户关联支付宝表-----------------------
	QueryTblUserAlipayDetail(ctx context.Context, in *TblUserAlipayFilter, opts ...grpc.CallOption) (*TblUserAlipay, error)
	QueryTblUserAlipayList(ctx context.Context, in *TblUserAlipayFilter, opts ...grpc.CallOption) (*TblUserAlipayList, error)
}

type tblUserAlipayClient struct {
	cc grpc.ClientConnInterface
}

func NewTblUserAlipayClient(cc grpc.ClientConnInterface) TblUserAlipayClient {
	return &tblUserAlipayClient{cc}
}

func (c *tblUserAlipayClient) QueryTblUserAlipayDetail(ctx context.Context, in *TblUserAlipayFilter, opts ...grpc.CallOption) (*TblUserAlipay, error) {
	out := new(TblUserAlipay)
	err := c.cc.Invoke(ctx, TblUserAlipay_QueryTblUserAlipayDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblUserAlipayClient) QueryTblUserAlipayList(ctx context.Context, in *TblUserAlipayFilter, opts ...grpc.CallOption) (*TblUserAlipayList, error) {
	out := new(TblUserAlipayList)
	err := c.cc.Invoke(ctx, TblUserAlipay_QueryTblUserAlipayList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TblUserAlipayServer is the server API for TblUserAlipay service.
// All implementations must embed UnimplementedTblUserAlipayServer
// for forward compatibility
type TblUserAlipayServer interface {
	// -----------------------COLUMNAR=1 用户关联支付宝表-----------------------
	QueryTblUserAlipayDetail(context.Context, *TblUserAlipayFilter) (*TblUserAlipay, error)
	QueryTblUserAlipayList(context.Context, *TblUserAlipayFilter) (*TblUserAlipayList, error)
	mustEmbedUnimplementedTblUserAlipayServer()
}

// UnimplementedTblUserAlipayServer must be embedded to have forward compatible implementations.
type UnimplementedTblUserAlipayServer struct {
}

func (UnimplementedTblUserAlipayServer) QueryTblUserAlipayDetail(context.Context, *TblUserAlipayFilter) (*TblUserAlipay, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblUserAlipayDetail not implemented")
}
func (UnimplementedTblUserAlipayServer) QueryTblUserAlipayList(context.Context, *TblUserAlipayFilter) (*TblUserAlipayList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblUserAlipayList not implemented")
}
func (UnimplementedTblUserAlipayServer) mustEmbedUnimplementedTblUserAlipayServer() {}

// UnsafeTblUserAlipayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TblUserAlipayServer will
// result in compilation errors.
type UnsafeTblUserAlipayServer interface {
	mustEmbedUnimplementedTblUserAlipayServer()
}

func RegisterTblUserAlipayServer(s grpc.ServiceRegistrar, srv TblUserAlipayServer) {
	s.RegisterService(&TblUserAlipay_ServiceDesc, srv)
}

func _TblUserAlipay_QueryTblUserAlipayDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblUserAlipayFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblUserAlipayServer).QueryTblUserAlipayDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblUserAlipay_QueryTblUserAlipayDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblUserAlipayServer).QueryTblUserAlipayDetail(ctx, req.(*TblUserAlipayFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblUserAlipay_QueryTblUserAlipayList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblUserAlipayFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblUserAlipayServer).QueryTblUserAlipayList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblUserAlipay_QueryTblUserAlipayList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblUserAlipayServer).QueryTblUserAlipayList(ctx, req.(*TblUserAlipayFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TblUserAlipay_ServiceDesc is the grpc.ServiceDesc for TblUserAlipay service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TblUserAlipay_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.tblUserAlipay",
	HandlerType: (*TblUserAlipayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryTblUserAlipayDetail",
			Handler:    _TblUserAlipay_QueryTblUserAlipayDetail_Handler,
		},
		{
			MethodName: "QueryTblUserAlipayList",
			Handler:    _TblUserAlipay_QueryTblUserAlipayList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	DiversionService_Allocate_FullMethodName = "/diversion.diversionService/Allocate"
)

// DiversionServiceClient is the client API for DiversionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiversionServiceClient interface {
	Allocate(ctx context.Context, in *AllocateRpcReq, opts ...grpc.CallOption) (*AllocateRpcResp, error)
}

type diversionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDiversionServiceClient(cc grpc.ClientConnInterface) DiversionServiceClient {
	return &diversionServiceClient{cc}
}

func (c *diversionServiceClient) Allocate(ctx context.Context, in *AllocateRpcReq, opts ...grpc.CallOption) (*AllocateRpcResp, error) {
	out := new(AllocateRpcResp)
	err := c.cc.Invoke(ctx, DiversionService_Allocate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiversionServiceServer is the server API for DiversionService service.
// All implementations must embed UnimplementedDiversionServiceServer
// for forward compatibility
type DiversionServiceServer interface {
	Allocate(context.Context, *AllocateRpcReq) (*AllocateRpcResp, error)
	mustEmbedUnimplementedDiversionServiceServer()
}

// UnimplementedDiversionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDiversionServiceServer struct {
}

func (UnimplementedDiversionServiceServer) Allocate(context.Context, *AllocateRpcReq) (*AllocateRpcResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Allocate not implemented")
}
func (UnimplementedDiversionServiceServer) mustEmbedUnimplementedDiversionServiceServer() {}

// UnsafeDiversionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiversionServiceServer will
// result in compilation errors.
type UnsafeDiversionServiceServer interface {
	mustEmbedUnimplementedDiversionServiceServer()
}

func RegisterDiversionServiceServer(s grpc.ServiceRegistrar, srv DiversionServiceServer) {
	s.RegisterService(&DiversionService_ServiceDesc, srv)
}

func _DiversionService_Allocate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateRpcReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiversionServiceServer).Allocate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiversionService_Allocate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiversionServiceServer).Allocate(ctx, req.(*AllocateRpcReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DiversionService_ServiceDesc is the grpc.ServiceDesc for DiversionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DiversionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.diversionService",
	HandlerType: (*DiversionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Allocate",
			Handler:    _DiversionService_Allocate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	DispatchService_Dispatch_FullMethodName          = "/diversion.dispatchService/Dispatch"
	DispatchService_Test_FullMethodName              = "/diversion.dispatchService/Test"
	DispatchService_QualityRatioLimit_FullMethodName = "/diversion.dispatchService/qualityRatioLimit"
)

// DispatchServiceClient is the client API for DispatchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DispatchServiceClient interface {
	Dispatch(ctx context.Context, in *DispatchRpcReq, opts ...grpc.CallOption) (*DispatchRpcResp, error)
	// 调试方法
	Test(ctx context.Context, in *DispatchRpcReq, opts ...grpc.CallOption) (*DispatchRpcResp, error)
	// 质量比例限制
	QualityRatioLimit(ctx context.Context, in *QualityRatioLimitReq, opts ...grpc.CallOption) (*QualityRatioLimitResp, error)
}

type dispatchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDispatchServiceClient(cc grpc.ClientConnInterface) DispatchServiceClient {
	return &dispatchServiceClient{cc}
}

func (c *dispatchServiceClient) Dispatch(ctx context.Context, in *DispatchRpcReq, opts ...grpc.CallOption) (*DispatchRpcResp, error) {
	out := new(DispatchRpcResp)
	err := c.cc.Invoke(ctx, DispatchService_Dispatch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatchServiceClient) Test(ctx context.Context, in *DispatchRpcReq, opts ...grpc.CallOption) (*DispatchRpcResp, error) {
	out := new(DispatchRpcResp)
	err := c.cc.Invoke(ctx, DispatchService_Test_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispatchServiceClient) QualityRatioLimit(ctx context.Context, in *QualityRatioLimitReq, opts ...grpc.CallOption) (*QualityRatioLimitResp, error) {
	out := new(QualityRatioLimitResp)
	err := c.cc.Invoke(ctx, DispatchService_QualityRatioLimit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DispatchServiceServer is the server API for DispatchService service.
// All implementations must embed UnimplementedDispatchServiceServer
// for forward compatibility
type DispatchServiceServer interface {
	Dispatch(context.Context, *DispatchRpcReq) (*DispatchRpcResp, error)
	// 调试方法
	Test(context.Context, *DispatchRpcReq) (*DispatchRpcResp, error)
	// 质量比例限制
	QualityRatioLimit(context.Context, *QualityRatioLimitReq) (*QualityRatioLimitResp, error)
	mustEmbedUnimplementedDispatchServiceServer()
}

// UnimplementedDispatchServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDispatchServiceServer struct {
}

func (UnimplementedDispatchServiceServer) Dispatch(context.Context, *DispatchRpcReq) (*DispatchRpcResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dispatch not implemented")
}
func (UnimplementedDispatchServiceServer) Test(context.Context, *DispatchRpcReq) (*DispatchRpcResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}
func (UnimplementedDispatchServiceServer) QualityRatioLimit(context.Context, *QualityRatioLimitReq) (*QualityRatioLimitResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QualityRatioLimit not implemented")
}
func (UnimplementedDispatchServiceServer) mustEmbedUnimplementedDispatchServiceServer() {}

// UnsafeDispatchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DispatchServiceServer will
// result in compilation errors.
type UnsafeDispatchServiceServer interface {
	mustEmbedUnimplementedDispatchServiceServer()
}

func RegisterDispatchServiceServer(s grpc.ServiceRegistrar, srv DispatchServiceServer) {
	s.RegisterService(&DispatchService_ServiceDesc, srv)
}

func _DispatchService_Dispatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DispatchRpcReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).Dispatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_Dispatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).Dispatch(ctx, req.(*DispatchRpcReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatchService_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DispatchRpcReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_Test_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).Test(ctx, req.(*DispatchRpcReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispatchService_QualityRatioLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QualityRatioLimitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispatchServiceServer).QualityRatioLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispatchService_QualityRatioLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispatchServiceServer).QualityRatioLimit(ctx, req.(*QualityRatioLimitReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DispatchService_ServiceDesc is the grpc.ServiceDesc for DispatchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DispatchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.dispatchService",
	HandlerType: (*DispatchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dispatch",
			Handler:    _DispatchService_Dispatch_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _DispatchService_Test_Handler,
		},
		{
			MethodName: "qualityRatioLimit",
			Handler:    _DispatchService_QualityRatioLimit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathDetail_FullMethodName = "/diversion.autoDispatchDecisionPath/QueryAutoDispatchDecisionPathDetail"
	AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathList_FullMethodName   = "/diversion.autoDispatchDecisionPath/QueryAutoDispatchDecisionPathList"
)

// AutoDispatchDecisionPathClient is the client API for AutoDispatchDecisionPath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutoDispatchDecisionPathClient interface {
	// -----------------------自动化派单决策路径表-----------------------
	QueryAutoDispatchDecisionPathDetail(ctx context.Context, in *AutoDispatchDecisionPathFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPath, error)
	QueryAutoDispatchDecisionPathList(ctx context.Context, in *AutoDispatchDecisionPathFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathList, error)
}

type autoDispatchDecisionPathClient struct {
	cc grpc.ClientConnInterface
}

func NewAutoDispatchDecisionPathClient(cc grpc.ClientConnInterface) AutoDispatchDecisionPathClient {
	return &autoDispatchDecisionPathClient{cc}
}

func (c *autoDispatchDecisionPathClient) QueryAutoDispatchDecisionPathDetail(ctx context.Context, in *AutoDispatchDecisionPathFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPath, error) {
	out := new(AutoDispatchDecisionPath)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionPathClient) QueryAutoDispatchDecisionPathList(ctx context.Context, in *AutoDispatchDecisionPathFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathList, error) {
	out := new(AutoDispatchDecisionPathList)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutoDispatchDecisionPathServer is the server API for AutoDispatchDecisionPath service.
// All implementations must embed UnimplementedAutoDispatchDecisionPathServer
// for forward compatibility
type AutoDispatchDecisionPathServer interface {
	// -----------------------自动化派单决策路径表-----------------------
	QueryAutoDispatchDecisionPathDetail(context.Context, *AutoDispatchDecisionPathFilter) (*AutoDispatchDecisionPath, error)
	QueryAutoDispatchDecisionPathList(context.Context, *AutoDispatchDecisionPathFilter) (*AutoDispatchDecisionPathList, error)
	mustEmbedUnimplementedAutoDispatchDecisionPathServer()
}

// UnimplementedAutoDispatchDecisionPathServer must be embedded to have forward compatible implementations.
type UnimplementedAutoDispatchDecisionPathServer struct {
}

func (UnimplementedAutoDispatchDecisionPathServer) QueryAutoDispatchDecisionPathDetail(context.Context, *AutoDispatchDecisionPathFilter) (*AutoDispatchDecisionPath, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionPathDetail not implemented")
}
func (UnimplementedAutoDispatchDecisionPathServer) QueryAutoDispatchDecisionPathList(context.Context, *AutoDispatchDecisionPathFilter) (*AutoDispatchDecisionPathList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionPathList not implemented")
}
func (UnimplementedAutoDispatchDecisionPathServer) mustEmbedUnimplementedAutoDispatchDecisionPathServer() {
}

// UnsafeAutoDispatchDecisionPathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutoDispatchDecisionPathServer will
// result in compilation errors.
type UnsafeAutoDispatchDecisionPathServer interface {
	mustEmbedUnimplementedAutoDispatchDecisionPathServer()
}

func RegisterAutoDispatchDecisionPathServer(s grpc.ServiceRegistrar, srv AutoDispatchDecisionPathServer) {
	s.RegisterService(&AutoDispatchDecisionPath_ServiceDesc, srv)
}

func _AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathServer).QueryAutoDispatchDecisionPathDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathServer).QueryAutoDispatchDecisionPathDetail(ctx, req.(*AutoDispatchDecisionPathFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathServer).QueryAutoDispatchDecisionPathList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathServer).QueryAutoDispatchDecisionPathList(ctx, req.(*AutoDispatchDecisionPathFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AutoDispatchDecisionPath_ServiceDesc is the grpc.ServiceDesc for AutoDispatchDecisionPath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AutoDispatchDecisionPath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.autoDispatchDecisionPath",
	HandlerType: (*AutoDispatchDecisionPathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryAutoDispatchDecisionPathDetail",
			Handler:    _AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathDetail_Handler,
		},
		{
			MethodName: "QueryAutoDispatchDecisionPathList",
			Handler:    _AutoDispatchDecisionPath_QueryAutoDispatchDecisionPathList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	CommodityActivityOrderSpu_CreateCommodityActivityOrderSpu_FullMethodName      = "/diversion.commodityActivityOrderSpu/CreateCommodityActivityOrderSpu"
	CommodityActivityOrderSpu_UpdateCommodityActivityOrderSpu_FullMethodName      = "/diversion.commodityActivityOrderSpu/UpdateCommodityActivityOrderSpu"
	CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuDetail_FullMethodName = "/diversion.commodityActivityOrderSpu/QueryCommodityActivityOrderSpuDetail"
	CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuList_FullMethodName   = "/diversion.commodityActivityOrderSpu/QueryCommodityActivityOrderSpuList"
)

// CommodityActivityOrderSpuClient is the client API for CommodityActivityOrderSpu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommodityActivityOrderSpuClient interface {
	// -----------------------活动订单spu-----------------------
	CreateCommodityActivityOrderSpu(ctx context.Context, in *CommodityActivityOrderSpu, opts ...grpc.CallOption) (*CommodityActivityOrderSpu, error)
	UpdateCommodityActivityOrderSpu(ctx context.Context, in *CommodityActivityOrderSpu, opts ...grpc.CallOption) (*CommodityActivityOrderSpu, error)
	QueryCommodityActivityOrderSpuDetail(ctx context.Context, in *CommodityActivityOrderSpuFilter, opts ...grpc.CallOption) (*CommodityActivityOrderSpu, error)
	QueryCommodityActivityOrderSpuList(ctx context.Context, in *CommodityActivityOrderSpuFilter, opts ...grpc.CallOption) (*CommodityActivityOrderSpuList, error)
}

type commodityActivityOrderSpuClient struct {
	cc grpc.ClientConnInterface
}

func NewCommodityActivityOrderSpuClient(cc grpc.ClientConnInterface) CommodityActivityOrderSpuClient {
	return &commodityActivityOrderSpuClient{cc}
}

func (c *commodityActivityOrderSpuClient) CreateCommodityActivityOrderSpu(ctx context.Context, in *CommodityActivityOrderSpu, opts ...grpc.CallOption) (*CommodityActivityOrderSpu, error) {
	out := new(CommodityActivityOrderSpu)
	err := c.cc.Invoke(ctx, CommodityActivityOrderSpu_CreateCommodityActivityOrderSpu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commodityActivityOrderSpuClient) UpdateCommodityActivityOrderSpu(ctx context.Context, in *CommodityActivityOrderSpu, opts ...grpc.CallOption) (*CommodityActivityOrderSpu, error) {
	out := new(CommodityActivityOrderSpu)
	err := c.cc.Invoke(ctx, CommodityActivityOrderSpu_UpdateCommodityActivityOrderSpu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commodityActivityOrderSpuClient) QueryCommodityActivityOrderSpuDetail(ctx context.Context, in *CommodityActivityOrderSpuFilter, opts ...grpc.CallOption) (*CommodityActivityOrderSpu, error) {
	out := new(CommodityActivityOrderSpu)
	err := c.cc.Invoke(ctx, CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commodityActivityOrderSpuClient) QueryCommodityActivityOrderSpuList(ctx context.Context, in *CommodityActivityOrderSpuFilter, opts ...grpc.CallOption) (*CommodityActivityOrderSpuList, error) {
	out := new(CommodityActivityOrderSpuList)
	err := c.cc.Invoke(ctx, CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommodityActivityOrderSpuServer is the server API for CommodityActivityOrderSpu service.
// All implementations must embed UnimplementedCommodityActivityOrderSpuServer
// for forward compatibility
type CommodityActivityOrderSpuServer interface {
	// -----------------------活动订单spu-----------------------
	CreateCommodityActivityOrderSpu(context.Context, *CommodityActivityOrderSpu) (*CommodityActivityOrderSpu, error)
	UpdateCommodityActivityOrderSpu(context.Context, *CommodityActivityOrderSpu) (*CommodityActivityOrderSpu, error)
	QueryCommodityActivityOrderSpuDetail(context.Context, *CommodityActivityOrderSpuFilter) (*CommodityActivityOrderSpu, error)
	QueryCommodityActivityOrderSpuList(context.Context, *CommodityActivityOrderSpuFilter) (*CommodityActivityOrderSpuList, error)
	mustEmbedUnimplementedCommodityActivityOrderSpuServer()
}

// UnimplementedCommodityActivityOrderSpuServer must be embedded to have forward compatible implementations.
type UnimplementedCommodityActivityOrderSpuServer struct {
}

func (UnimplementedCommodityActivityOrderSpuServer) CreateCommodityActivityOrderSpu(context.Context, *CommodityActivityOrderSpu) (*CommodityActivityOrderSpu, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCommodityActivityOrderSpu not implemented")
}
func (UnimplementedCommodityActivityOrderSpuServer) UpdateCommodityActivityOrderSpu(context.Context, *CommodityActivityOrderSpu) (*CommodityActivityOrderSpu, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCommodityActivityOrderSpu not implemented")
}
func (UnimplementedCommodityActivityOrderSpuServer) QueryCommodityActivityOrderSpuDetail(context.Context, *CommodityActivityOrderSpuFilter) (*CommodityActivityOrderSpu, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCommodityActivityOrderSpuDetail not implemented")
}
func (UnimplementedCommodityActivityOrderSpuServer) QueryCommodityActivityOrderSpuList(context.Context, *CommodityActivityOrderSpuFilter) (*CommodityActivityOrderSpuList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCommodityActivityOrderSpuList not implemented")
}
func (UnimplementedCommodityActivityOrderSpuServer) mustEmbedUnimplementedCommodityActivityOrderSpuServer() {
}

// UnsafeCommodityActivityOrderSpuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommodityActivityOrderSpuServer will
// result in compilation errors.
type UnsafeCommodityActivityOrderSpuServer interface {
	mustEmbedUnimplementedCommodityActivityOrderSpuServer()
}

func RegisterCommodityActivityOrderSpuServer(s grpc.ServiceRegistrar, srv CommodityActivityOrderSpuServer) {
	s.RegisterService(&CommodityActivityOrderSpu_ServiceDesc, srv)
}

func _CommodityActivityOrderSpu_CreateCommodityActivityOrderSpu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommodityActivityOrderSpu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityActivityOrderSpuServer).CreateCommodityActivityOrderSpu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommodityActivityOrderSpu_CreateCommodityActivityOrderSpu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityActivityOrderSpuServer).CreateCommodityActivityOrderSpu(ctx, req.(*CommodityActivityOrderSpu))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommodityActivityOrderSpu_UpdateCommodityActivityOrderSpu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommodityActivityOrderSpu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityActivityOrderSpuServer).UpdateCommodityActivityOrderSpu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommodityActivityOrderSpu_UpdateCommodityActivityOrderSpu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityActivityOrderSpuServer).UpdateCommodityActivityOrderSpu(ctx, req.(*CommodityActivityOrderSpu))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommodityActivityOrderSpuFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityActivityOrderSpuServer).QueryCommodityActivityOrderSpuDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityActivityOrderSpuServer).QueryCommodityActivityOrderSpuDetail(ctx, req.(*CommodityActivityOrderSpuFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommodityActivityOrderSpuFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommodityActivityOrderSpuServer).QueryCommodityActivityOrderSpuList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommodityActivityOrderSpuServer).QueryCommodityActivityOrderSpuList(ctx, req.(*CommodityActivityOrderSpuFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// CommodityActivityOrderSpu_ServiceDesc is the grpc.ServiceDesc for CommodityActivityOrderSpu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommodityActivityOrderSpu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.commodityActivityOrderSpu",
	HandlerType: (*CommodityActivityOrderSpuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCommodityActivityOrderSpu",
			Handler:    _CommodityActivityOrderSpu_CreateCommodityActivityOrderSpu_Handler,
		},
		{
			MethodName: "UpdateCommodityActivityOrderSpu",
			Handler:    _CommodityActivityOrderSpu_UpdateCommodityActivityOrderSpu_Handler,
		},
		{
			MethodName: "QueryCommodityActivityOrderSpuDetail",
			Handler:    _CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuDetail_Handler,
		},
		{
			MethodName: "QueryCommodityActivityOrderSpuList",
			Handler:    _CommodityActivityOrderSpu_QueryCommodityActivityOrderSpuList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	TblDispatchOrderFactor_QueryTblDispatchOrderFactorDetail_FullMethodName = "/diversion.tblDispatchOrderFactor/QueryTblDispatchOrderFactorDetail"
	TblDispatchOrderFactor_QueryTblDispatchOrderFactorList_FullMethodName   = "/diversion.tblDispatchOrderFactor/QueryTblDispatchOrderFactorList"
)

// TblDispatchOrderFactorClient is the client API for TblDispatchOrderFactor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TblDispatchOrderFactorClient interface {
	// -----------------------派单因子表-----------------------
	QueryTblDispatchOrderFactorDetail(ctx context.Context, in *TblDispatchOrderFactorFilter, opts ...grpc.CallOption) (*TblDispatchOrderFactor, error)
	QueryTblDispatchOrderFactorList(ctx context.Context, in *TblDispatchOrderFactorFilter, opts ...grpc.CallOption) (*TblDispatchOrderFactorList, error)
}

type tblDispatchOrderFactorClient struct {
	cc grpc.ClientConnInterface
}

func NewTblDispatchOrderFactorClient(cc grpc.ClientConnInterface) TblDispatchOrderFactorClient {
	return &tblDispatchOrderFactorClient{cc}
}

func (c *tblDispatchOrderFactorClient) QueryTblDispatchOrderFactorDetail(ctx context.Context, in *TblDispatchOrderFactorFilter, opts ...grpc.CallOption) (*TblDispatchOrderFactor, error) {
	out := new(TblDispatchOrderFactor)
	err := c.cc.Invoke(ctx, TblDispatchOrderFactor_QueryTblDispatchOrderFactorDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblDispatchOrderFactorClient) QueryTblDispatchOrderFactorList(ctx context.Context, in *TblDispatchOrderFactorFilter, opts ...grpc.CallOption) (*TblDispatchOrderFactorList, error) {
	out := new(TblDispatchOrderFactorList)
	err := c.cc.Invoke(ctx, TblDispatchOrderFactor_QueryTblDispatchOrderFactorList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TblDispatchOrderFactorServer is the server API for TblDispatchOrderFactor service.
// All implementations must embed UnimplementedTblDispatchOrderFactorServer
// for forward compatibility
type TblDispatchOrderFactorServer interface {
	// -----------------------派单因子表-----------------------
	QueryTblDispatchOrderFactorDetail(context.Context, *TblDispatchOrderFactorFilter) (*TblDispatchOrderFactor, error)
	QueryTblDispatchOrderFactorList(context.Context, *TblDispatchOrderFactorFilter) (*TblDispatchOrderFactorList, error)
	mustEmbedUnimplementedTblDispatchOrderFactorServer()
}

// UnimplementedTblDispatchOrderFactorServer must be embedded to have forward compatible implementations.
type UnimplementedTblDispatchOrderFactorServer struct {
}

func (UnimplementedTblDispatchOrderFactorServer) QueryTblDispatchOrderFactorDetail(context.Context, *TblDispatchOrderFactorFilter) (*TblDispatchOrderFactor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblDispatchOrderFactorDetail not implemented")
}
func (UnimplementedTblDispatchOrderFactorServer) QueryTblDispatchOrderFactorList(context.Context, *TblDispatchOrderFactorFilter) (*TblDispatchOrderFactorList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblDispatchOrderFactorList not implemented")
}
func (UnimplementedTblDispatchOrderFactorServer) mustEmbedUnimplementedTblDispatchOrderFactorServer() {
}

// UnsafeTblDispatchOrderFactorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TblDispatchOrderFactorServer will
// result in compilation errors.
type UnsafeTblDispatchOrderFactorServer interface {
	mustEmbedUnimplementedTblDispatchOrderFactorServer()
}

func RegisterTblDispatchOrderFactorServer(s grpc.ServiceRegistrar, srv TblDispatchOrderFactorServer) {
	s.RegisterService(&TblDispatchOrderFactor_ServiceDesc, srv)
}

func _TblDispatchOrderFactor_QueryTblDispatchOrderFactorDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblDispatchOrderFactorFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblDispatchOrderFactorServer).QueryTblDispatchOrderFactorDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblDispatchOrderFactor_QueryTblDispatchOrderFactorDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblDispatchOrderFactorServer).QueryTblDispatchOrderFactorDetail(ctx, req.(*TblDispatchOrderFactorFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblDispatchOrderFactor_QueryTblDispatchOrderFactorList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblDispatchOrderFactorFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblDispatchOrderFactorServer).QueryTblDispatchOrderFactorList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblDispatchOrderFactor_QueryTblDispatchOrderFactorList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblDispatchOrderFactorServer).QueryTblDispatchOrderFactorList(ctx, req.(*TblDispatchOrderFactorFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TblDispatchOrderFactor_ServiceDesc is the grpc.ServiceDesc for TblDispatchOrderFactor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TblDispatchOrderFactor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.tblDispatchOrderFactor",
	HandlerType: (*TblDispatchOrderFactorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryTblDispatchOrderFactorDetail",
			Handler:    _TblDispatchOrderFactor_QueryTblDispatchOrderFactorDetail_Handler,
		},
		{
			MethodName: "QueryTblDispatchOrderFactorList",
			Handler:    _TblDispatchOrderFactor_QueryTblDispatchOrderFactorList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	TblServerDistributeLimitRules_CreateTblServerDistributeLimitRules_FullMethodName      = "/diversion.tblServerDistributeLimitRules/CreateTblServerDistributeLimitRules"
	TblServerDistributeLimitRules_UpdateTblServerDistributeLimitRules_FullMethodName      = "/diversion.tblServerDistributeLimitRules/UpdateTblServerDistributeLimitRules"
	TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesDetail_FullMethodName = "/diversion.tblServerDistributeLimitRules/QueryTblServerDistributeLimitRulesDetail"
	TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesList_FullMethodName   = "/diversion.tblServerDistributeLimitRules/QueryTblServerDistributeLimitRulesList"
)

// TblServerDistributeLimitRulesClient is the client API for TblServerDistributeLimitRules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TblServerDistributeLimitRulesClient interface {
	// -----------------------商家派单规则限制表-----------------------
	CreateTblServerDistributeLimitRules(ctx context.Context, in *TblServerDistributeLimitRules, opts ...grpc.CallOption) (*TblServerDistributeLimitRules, error)
	UpdateTblServerDistributeLimitRules(ctx context.Context, in *TblServerDistributeLimitRules, opts ...grpc.CallOption) (*TblServerDistributeLimitRules, error)
	QueryTblServerDistributeLimitRulesDetail(ctx context.Context, in *TblServerDistributeLimitRulesFilter, opts ...grpc.CallOption) (*TblServerDistributeLimitRules, error)
	QueryTblServerDistributeLimitRulesList(ctx context.Context, in *TblServerDistributeLimitRulesFilter, opts ...grpc.CallOption) (*TblServerDistributeLimitRulesList, error)
}

type tblServerDistributeLimitRulesClient struct {
	cc grpc.ClientConnInterface
}

func NewTblServerDistributeLimitRulesClient(cc grpc.ClientConnInterface) TblServerDistributeLimitRulesClient {
	return &tblServerDistributeLimitRulesClient{cc}
}

func (c *tblServerDistributeLimitRulesClient) CreateTblServerDistributeLimitRules(ctx context.Context, in *TblServerDistributeLimitRules, opts ...grpc.CallOption) (*TblServerDistributeLimitRules, error) {
	out := new(TblServerDistributeLimitRules)
	err := c.cc.Invoke(ctx, TblServerDistributeLimitRules_CreateTblServerDistributeLimitRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblServerDistributeLimitRulesClient) UpdateTblServerDistributeLimitRules(ctx context.Context, in *TblServerDistributeLimitRules, opts ...grpc.CallOption) (*TblServerDistributeLimitRules, error) {
	out := new(TblServerDistributeLimitRules)
	err := c.cc.Invoke(ctx, TblServerDistributeLimitRules_UpdateTblServerDistributeLimitRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblServerDistributeLimitRulesClient) QueryTblServerDistributeLimitRulesDetail(ctx context.Context, in *TblServerDistributeLimitRulesFilter, opts ...grpc.CallOption) (*TblServerDistributeLimitRules, error) {
	out := new(TblServerDistributeLimitRules)
	err := c.cc.Invoke(ctx, TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblServerDistributeLimitRulesClient) QueryTblServerDistributeLimitRulesList(ctx context.Context, in *TblServerDistributeLimitRulesFilter, opts ...grpc.CallOption) (*TblServerDistributeLimitRulesList, error) {
	out := new(TblServerDistributeLimitRulesList)
	err := c.cc.Invoke(ctx, TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TblServerDistributeLimitRulesServer is the server API for TblServerDistributeLimitRules service.
// All implementations must embed UnimplementedTblServerDistributeLimitRulesServer
// for forward compatibility
type TblServerDistributeLimitRulesServer interface {
	// -----------------------商家派单规则限制表-----------------------
	CreateTblServerDistributeLimitRules(context.Context, *TblServerDistributeLimitRules) (*TblServerDistributeLimitRules, error)
	UpdateTblServerDistributeLimitRules(context.Context, *TblServerDistributeLimitRules) (*TblServerDistributeLimitRules, error)
	QueryTblServerDistributeLimitRulesDetail(context.Context, *TblServerDistributeLimitRulesFilter) (*TblServerDistributeLimitRules, error)
	QueryTblServerDistributeLimitRulesList(context.Context, *TblServerDistributeLimitRulesFilter) (*TblServerDistributeLimitRulesList, error)
	mustEmbedUnimplementedTblServerDistributeLimitRulesServer()
}

// UnimplementedTblServerDistributeLimitRulesServer must be embedded to have forward compatible implementations.
type UnimplementedTblServerDistributeLimitRulesServer struct {
}

func (UnimplementedTblServerDistributeLimitRulesServer) CreateTblServerDistributeLimitRules(context.Context, *TblServerDistributeLimitRules) (*TblServerDistributeLimitRules, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTblServerDistributeLimitRules not implemented")
}
func (UnimplementedTblServerDistributeLimitRulesServer) UpdateTblServerDistributeLimitRules(context.Context, *TblServerDistributeLimitRules) (*TblServerDistributeLimitRules, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTblServerDistributeLimitRules not implemented")
}
func (UnimplementedTblServerDistributeLimitRulesServer) QueryTblServerDistributeLimitRulesDetail(context.Context, *TblServerDistributeLimitRulesFilter) (*TblServerDistributeLimitRules, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblServerDistributeLimitRulesDetail not implemented")
}
func (UnimplementedTblServerDistributeLimitRulesServer) QueryTblServerDistributeLimitRulesList(context.Context, *TblServerDistributeLimitRulesFilter) (*TblServerDistributeLimitRulesList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblServerDistributeLimitRulesList not implemented")
}
func (UnimplementedTblServerDistributeLimitRulesServer) mustEmbedUnimplementedTblServerDistributeLimitRulesServer() {
}

// UnsafeTblServerDistributeLimitRulesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TblServerDistributeLimitRulesServer will
// result in compilation errors.
type UnsafeTblServerDistributeLimitRulesServer interface {
	mustEmbedUnimplementedTblServerDistributeLimitRulesServer()
}

func RegisterTblServerDistributeLimitRulesServer(s grpc.ServiceRegistrar, srv TblServerDistributeLimitRulesServer) {
	s.RegisterService(&TblServerDistributeLimitRules_ServiceDesc, srv)
}

func _TblServerDistributeLimitRules_CreateTblServerDistributeLimitRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblServerDistributeLimitRules)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblServerDistributeLimitRulesServer).CreateTblServerDistributeLimitRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblServerDistributeLimitRules_CreateTblServerDistributeLimitRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblServerDistributeLimitRulesServer).CreateTblServerDistributeLimitRules(ctx, req.(*TblServerDistributeLimitRules))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblServerDistributeLimitRules_UpdateTblServerDistributeLimitRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblServerDistributeLimitRules)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblServerDistributeLimitRulesServer).UpdateTblServerDistributeLimitRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblServerDistributeLimitRules_UpdateTblServerDistributeLimitRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblServerDistributeLimitRulesServer).UpdateTblServerDistributeLimitRules(ctx, req.(*TblServerDistributeLimitRules))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblServerDistributeLimitRulesFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblServerDistributeLimitRulesServer).QueryTblServerDistributeLimitRulesDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblServerDistributeLimitRulesServer).QueryTblServerDistributeLimitRulesDetail(ctx, req.(*TblServerDistributeLimitRulesFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblServerDistributeLimitRulesFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblServerDistributeLimitRulesServer).QueryTblServerDistributeLimitRulesList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblServerDistributeLimitRulesServer).QueryTblServerDistributeLimitRulesList(ctx, req.(*TblServerDistributeLimitRulesFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TblServerDistributeLimitRules_ServiceDesc is the grpc.ServiceDesc for TblServerDistributeLimitRules service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TblServerDistributeLimitRules_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.tblServerDistributeLimitRules",
	HandlerType: (*TblServerDistributeLimitRulesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTblServerDistributeLimitRules",
			Handler:    _TblServerDistributeLimitRules_CreateTblServerDistributeLimitRules_Handler,
		},
		{
			MethodName: "UpdateTblServerDistributeLimitRules",
			Handler:    _TblServerDistributeLimitRules_UpdateTblServerDistributeLimitRules_Handler,
		},
		{
			MethodName: "QueryTblServerDistributeLimitRulesDetail",
			Handler:    _TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesDetail_Handler,
		},
		{
			MethodName: "QueryTblServerDistributeLimitRulesList",
			Handler:    _TblServerDistributeLimitRules_QueryTblServerDistributeLimitRulesList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	DistributeOrderLog_CreateDistributeOrderLog_FullMethodName      = "/diversion.distributeOrderLog/CreateDistributeOrderLog"
	DistributeOrderLog_UpdateDistributeOrderLog_FullMethodName      = "/diversion.distributeOrderLog/UpdateDistributeOrderLog"
	DistributeOrderLog_QueryDistributeOrderLogDetail_FullMethodName = "/diversion.distributeOrderLog/QueryDistributeOrderLogDetail"
	DistributeOrderLog_QueryDistributeOrderLogList_FullMethodName   = "/diversion.distributeOrderLog/QueryDistributeOrderLogList"
)

// DistributeOrderLogClient is the client API for DistributeOrderLog service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DistributeOrderLogClient interface {
	// -----------------------派单记录表-----------------------
	CreateDistributeOrderLog(ctx context.Context, in *DistributeOrderLog, opts ...grpc.CallOption) (*DistributeOrderLog, error)
	UpdateDistributeOrderLog(ctx context.Context, in *DistributeOrderLog, opts ...grpc.CallOption) (*DistributeOrderLog, error)
	QueryDistributeOrderLogDetail(ctx context.Context, in *DistributeOrderLogFilter, opts ...grpc.CallOption) (*DistributeOrderLog, error)
	QueryDistributeOrderLogList(ctx context.Context, in *DistributeOrderLogFilter, opts ...grpc.CallOption) (*DistributeOrderLogList, error)
}

type distributeOrderLogClient struct {
	cc grpc.ClientConnInterface
}

func NewDistributeOrderLogClient(cc grpc.ClientConnInterface) DistributeOrderLogClient {
	return &distributeOrderLogClient{cc}
}

func (c *distributeOrderLogClient) CreateDistributeOrderLog(ctx context.Context, in *DistributeOrderLog, opts ...grpc.CallOption) (*DistributeOrderLog, error) {
	out := new(DistributeOrderLog)
	err := c.cc.Invoke(ctx, DistributeOrderLog_CreateDistributeOrderLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributeOrderLogClient) UpdateDistributeOrderLog(ctx context.Context, in *DistributeOrderLog, opts ...grpc.CallOption) (*DistributeOrderLog, error) {
	out := new(DistributeOrderLog)
	err := c.cc.Invoke(ctx, DistributeOrderLog_UpdateDistributeOrderLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributeOrderLogClient) QueryDistributeOrderLogDetail(ctx context.Context, in *DistributeOrderLogFilter, opts ...grpc.CallOption) (*DistributeOrderLog, error) {
	out := new(DistributeOrderLog)
	err := c.cc.Invoke(ctx, DistributeOrderLog_QueryDistributeOrderLogDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributeOrderLogClient) QueryDistributeOrderLogList(ctx context.Context, in *DistributeOrderLogFilter, opts ...grpc.CallOption) (*DistributeOrderLogList, error) {
	out := new(DistributeOrderLogList)
	err := c.cc.Invoke(ctx, DistributeOrderLog_QueryDistributeOrderLogList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DistributeOrderLogServer is the server API for DistributeOrderLog service.
// All implementations must embed UnimplementedDistributeOrderLogServer
// for forward compatibility
type DistributeOrderLogServer interface {
	// -----------------------派单记录表-----------------------
	CreateDistributeOrderLog(context.Context, *DistributeOrderLog) (*DistributeOrderLog, error)
	UpdateDistributeOrderLog(context.Context, *DistributeOrderLog) (*DistributeOrderLog, error)
	QueryDistributeOrderLogDetail(context.Context, *DistributeOrderLogFilter) (*DistributeOrderLog, error)
	QueryDistributeOrderLogList(context.Context, *DistributeOrderLogFilter) (*DistributeOrderLogList, error)
	mustEmbedUnimplementedDistributeOrderLogServer()
}

// UnimplementedDistributeOrderLogServer must be embedded to have forward compatible implementations.
type UnimplementedDistributeOrderLogServer struct {
}

func (UnimplementedDistributeOrderLogServer) CreateDistributeOrderLog(context.Context, *DistributeOrderLog) (*DistributeOrderLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDistributeOrderLog not implemented")
}
func (UnimplementedDistributeOrderLogServer) UpdateDistributeOrderLog(context.Context, *DistributeOrderLog) (*DistributeOrderLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDistributeOrderLog not implemented")
}
func (UnimplementedDistributeOrderLogServer) QueryDistributeOrderLogDetail(context.Context, *DistributeOrderLogFilter) (*DistributeOrderLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDistributeOrderLogDetail not implemented")
}
func (UnimplementedDistributeOrderLogServer) QueryDistributeOrderLogList(context.Context, *DistributeOrderLogFilter) (*DistributeOrderLogList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDistributeOrderLogList not implemented")
}
func (UnimplementedDistributeOrderLogServer) mustEmbedUnimplementedDistributeOrderLogServer() {}

// UnsafeDistributeOrderLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DistributeOrderLogServer will
// result in compilation errors.
type UnsafeDistributeOrderLogServer interface {
	mustEmbedUnimplementedDistributeOrderLogServer()
}

func RegisterDistributeOrderLogServer(s grpc.ServiceRegistrar, srv DistributeOrderLogServer) {
	s.RegisterService(&DistributeOrderLog_ServiceDesc, srv)
}

func _DistributeOrderLog_CreateDistributeOrderLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistributeOrderLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributeOrderLogServer).CreateDistributeOrderLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributeOrderLog_CreateDistributeOrderLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributeOrderLogServer).CreateDistributeOrderLog(ctx, req.(*DistributeOrderLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributeOrderLog_UpdateDistributeOrderLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistributeOrderLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributeOrderLogServer).UpdateDistributeOrderLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributeOrderLog_UpdateDistributeOrderLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributeOrderLogServer).UpdateDistributeOrderLog(ctx, req.(*DistributeOrderLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributeOrderLog_QueryDistributeOrderLogDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistributeOrderLogFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributeOrderLogServer).QueryDistributeOrderLogDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributeOrderLog_QueryDistributeOrderLogDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributeOrderLogServer).QueryDistributeOrderLogDetail(ctx, req.(*DistributeOrderLogFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributeOrderLog_QueryDistributeOrderLogList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistributeOrderLogFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributeOrderLogServer).QueryDistributeOrderLogList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributeOrderLog_QueryDistributeOrderLogList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributeOrderLogServer).QueryDistributeOrderLogList(ctx, req.(*DistributeOrderLogFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// DistributeOrderLog_ServiceDesc is the grpc.ServiceDesc for DistributeOrderLog service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DistributeOrderLog_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.distributeOrderLog",
	HandlerType: (*DistributeOrderLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDistributeOrderLog",
			Handler:    _DistributeOrderLog_CreateDistributeOrderLog_Handler,
		},
		{
			MethodName: "UpdateDistributeOrderLog",
			Handler:    _DistributeOrderLog_UpdateDistributeOrderLog_Handler,
		},
		{
			MethodName: "QueryDistributeOrderLogDetail",
			Handler:    _DistributeOrderLog_QueryDistributeOrderLogDetail_Handler,
		},
		{
			MethodName: "QueryDistributeOrderLogList",
			Handler:    _DistributeOrderLog_QueryDistributeOrderLogList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	TblDispatchServerFlowPool_CreateTblDispatchServerFlowPool_FullMethodName      = "/diversion.tblDispatchServerFlowPool/CreateTblDispatchServerFlowPool"
	TblDispatchServerFlowPool_UpdateTblDispatchServerFlowPool_FullMethodName      = "/diversion.tblDispatchServerFlowPool/UpdateTblDispatchServerFlowPool"
	TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolDetail_FullMethodName = "/diversion.tblDispatchServerFlowPool/QueryTblDispatchServerFlowPoolDetail"
	TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolList_FullMethodName   = "/diversion.tblDispatchServerFlowPool/QueryTblDispatchServerFlowPoolList"
)

// TblDispatchServerFlowPoolClient is the client API for TblDispatchServerFlowPool service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TblDispatchServerFlowPoolClient interface {
	// -----------------------派单商家流量池表-----------------------
	CreateTblDispatchServerFlowPool(ctx context.Context, in *TblDispatchServerFlowPool, opts ...grpc.CallOption) (*TblDispatchServerFlowPool, error)
	UpdateTblDispatchServerFlowPool(ctx context.Context, in *TblDispatchServerFlowPool, opts ...grpc.CallOption) (*TblDispatchServerFlowPool, error)
	QueryTblDispatchServerFlowPoolDetail(ctx context.Context, in *TblDispatchServerFlowPoolFilter, opts ...grpc.CallOption) (*TblDispatchServerFlowPool, error)
	QueryTblDispatchServerFlowPoolList(ctx context.Context, in *TblDispatchServerFlowPoolFilter, opts ...grpc.CallOption) (*TblDispatchServerFlowPoolList, error)
}

type tblDispatchServerFlowPoolClient struct {
	cc grpc.ClientConnInterface
}

func NewTblDispatchServerFlowPoolClient(cc grpc.ClientConnInterface) TblDispatchServerFlowPoolClient {
	return &tblDispatchServerFlowPoolClient{cc}
}

func (c *tblDispatchServerFlowPoolClient) CreateTblDispatchServerFlowPool(ctx context.Context, in *TblDispatchServerFlowPool, opts ...grpc.CallOption) (*TblDispatchServerFlowPool, error) {
	out := new(TblDispatchServerFlowPool)
	err := c.cc.Invoke(ctx, TblDispatchServerFlowPool_CreateTblDispatchServerFlowPool_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblDispatchServerFlowPoolClient) UpdateTblDispatchServerFlowPool(ctx context.Context, in *TblDispatchServerFlowPool, opts ...grpc.CallOption) (*TblDispatchServerFlowPool, error) {
	out := new(TblDispatchServerFlowPool)
	err := c.cc.Invoke(ctx, TblDispatchServerFlowPool_UpdateTblDispatchServerFlowPool_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblDispatchServerFlowPoolClient) QueryTblDispatchServerFlowPoolDetail(ctx context.Context, in *TblDispatchServerFlowPoolFilter, opts ...grpc.CallOption) (*TblDispatchServerFlowPool, error) {
	out := new(TblDispatchServerFlowPool)
	err := c.cc.Invoke(ctx, TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tblDispatchServerFlowPoolClient) QueryTblDispatchServerFlowPoolList(ctx context.Context, in *TblDispatchServerFlowPoolFilter, opts ...grpc.CallOption) (*TblDispatchServerFlowPoolList, error) {
	out := new(TblDispatchServerFlowPoolList)
	err := c.cc.Invoke(ctx, TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TblDispatchServerFlowPoolServer is the server API for TblDispatchServerFlowPool service.
// All implementations must embed UnimplementedTblDispatchServerFlowPoolServer
// for forward compatibility
type TblDispatchServerFlowPoolServer interface {
	// -----------------------派单商家流量池表-----------------------
	CreateTblDispatchServerFlowPool(context.Context, *TblDispatchServerFlowPool) (*TblDispatchServerFlowPool, error)
	UpdateTblDispatchServerFlowPool(context.Context, *TblDispatchServerFlowPool) (*TblDispatchServerFlowPool, error)
	QueryTblDispatchServerFlowPoolDetail(context.Context, *TblDispatchServerFlowPoolFilter) (*TblDispatchServerFlowPool, error)
	QueryTblDispatchServerFlowPoolList(context.Context, *TblDispatchServerFlowPoolFilter) (*TblDispatchServerFlowPoolList, error)
	mustEmbedUnimplementedTblDispatchServerFlowPoolServer()
}

// UnimplementedTblDispatchServerFlowPoolServer must be embedded to have forward compatible implementations.
type UnimplementedTblDispatchServerFlowPoolServer struct {
}

func (UnimplementedTblDispatchServerFlowPoolServer) CreateTblDispatchServerFlowPool(context.Context, *TblDispatchServerFlowPool) (*TblDispatchServerFlowPool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTblDispatchServerFlowPool not implemented")
}
func (UnimplementedTblDispatchServerFlowPoolServer) UpdateTblDispatchServerFlowPool(context.Context, *TblDispatchServerFlowPool) (*TblDispatchServerFlowPool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTblDispatchServerFlowPool not implemented")
}
func (UnimplementedTblDispatchServerFlowPoolServer) QueryTblDispatchServerFlowPoolDetail(context.Context, *TblDispatchServerFlowPoolFilter) (*TblDispatchServerFlowPool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblDispatchServerFlowPoolDetail not implemented")
}
func (UnimplementedTblDispatchServerFlowPoolServer) QueryTblDispatchServerFlowPoolList(context.Context, *TblDispatchServerFlowPoolFilter) (*TblDispatchServerFlowPoolList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTblDispatchServerFlowPoolList not implemented")
}
func (UnimplementedTblDispatchServerFlowPoolServer) mustEmbedUnimplementedTblDispatchServerFlowPoolServer() {
}

// UnsafeTblDispatchServerFlowPoolServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TblDispatchServerFlowPoolServer will
// result in compilation errors.
type UnsafeTblDispatchServerFlowPoolServer interface {
	mustEmbedUnimplementedTblDispatchServerFlowPoolServer()
}

func RegisterTblDispatchServerFlowPoolServer(s grpc.ServiceRegistrar, srv TblDispatchServerFlowPoolServer) {
	s.RegisterService(&TblDispatchServerFlowPool_ServiceDesc, srv)
}

func _TblDispatchServerFlowPool_CreateTblDispatchServerFlowPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblDispatchServerFlowPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblDispatchServerFlowPoolServer).CreateTblDispatchServerFlowPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblDispatchServerFlowPool_CreateTblDispatchServerFlowPool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblDispatchServerFlowPoolServer).CreateTblDispatchServerFlowPool(ctx, req.(*TblDispatchServerFlowPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblDispatchServerFlowPool_UpdateTblDispatchServerFlowPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblDispatchServerFlowPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblDispatchServerFlowPoolServer).UpdateTblDispatchServerFlowPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblDispatchServerFlowPool_UpdateTblDispatchServerFlowPool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblDispatchServerFlowPoolServer).UpdateTblDispatchServerFlowPool(ctx, req.(*TblDispatchServerFlowPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblDispatchServerFlowPoolFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblDispatchServerFlowPoolServer).QueryTblDispatchServerFlowPoolDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblDispatchServerFlowPoolServer).QueryTblDispatchServerFlowPoolDetail(ctx, req.(*TblDispatchServerFlowPoolFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TblDispatchServerFlowPoolFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TblDispatchServerFlowPoolServer).QueryTblDispatchServerFlowPoolList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TblDispatchServerFlowPoolServer).QueryTblDispatchServerFlowPoolList(ctx, req.(*TblDispatchServerFlowPoolFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// TblDispatchServerFlowPool_ServiceDesc is the grpc.ServiceDesc for TblDispatchServerFlowPool service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TblDispatchServerFlowPool_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.tblDispatchServerFlowPool",
	HandlerType: (*TblDispatchServerFlowPoolServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTblDispatchServerFlowPool",
			Handler:    _TblDispatchServerFlowPool_CreateTblDispatchServerFlowPool_Handler,
		},
		{
			MethodName: "UpdateTblDispatchServerFlowPool",
			Handler:    _TblDispatchServerFlowPool_UpdateTblDispatchServerFlowPool_Handler,
		},
		{
			MethodName: "QueryTblDispatchServerFlowPoolDetail",
			Handler:    _TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolDetail_Handler,
		},
		{
			MethodName: "QueryTblDispatchServerFlowPoolList",
			Handler:    _TblDispatchServerFlowPool_QueryTblDispatchServerFlowPoolList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AutoDispatchDecisionPathLink_CreateAutoDispatchDecisionPathLink_FullMethodName      = "/diversion.autoDispatchDecisionPathLink/CreateAutoDispatchDecisionPathLink"
	AutoDispatchDecisionPathLink_UpdateAutoDispatchDecisionPathLink_FullMethodName      = "/diversion.autoDispatchDecisionPathLink/UpdateAutoDispatchDecisionPathLink"
	AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkDetail_FullMethodName = "/diversion.autoDispatchDecisionPathLink/QueryAutoDispatchDecisionPathLinkDetail"
	AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkList_FullMethodName   = "/diversion.autoDispatchDecisionPathLink/QueryAutoDispatchDecisionPathLinkList"
)

// AutoDispatchDecisionPathLinkClient is the client API for AutoDispatchDecisionPathLink service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutoDispatchDecisionPathLinkClient interface {
	// -----------------------自动化派单决策路径应用表-----------------------
	CreateAutoDispatchDecisionPathLink(ctx context.Context, in *AutoDispatchDecisionPathLink, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLink, error)
	UpdateAutoDispatchDecisionPathLink(ctx context.Context, in *AutoDispatchDecisionPathLink, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLink, error)
	QueryAutoDispatchDecisionPathLinkDetail(ctx context.Context, in *AutoDispatchDecisionPathLinkFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLink, error)
	QueryAutoDispatchDecisionPathLinkList(ctx context.Context, in *AutoDispatchDecisionPathLinkFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLinkList, error)
}

type autoDispatchDecisionPathLinkClient struct {
	cc grpc.ClientConnInterface
}

func NewAutoDispatchDecisionPathLinkClient(cc grpc.ClientConnInterface) AutoDispatchDecisionPathLinkClient {
	return &autoDispatchDecisionPathLinkClient{cc}
}

func (c *autoDispatchDecisionPathLinkClient) CreateAutoDispatchDecisionPathLink(ctx context.Context, in *AutoDispatchDecisionPathLink, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLink, error) {
	out := new(AutoDispatchDecisionPathLink)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathLink_CreateAutoDispatchDecisionPathLink_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionPathLinkClient) UpdateAutoDispatchDecisionPathLink(ctx context.Context, in *AutoDispatchDecisionPathLink, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLink, error) {
	out := new(AutoDispatchDecisionPathLink)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathLink_UpdateAutoDispatchDecisionPathLink_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionPathLinkClient) QueryAutoDispatchDecisionPathLinkDetail(ctx context.Context, in *AutoDispatchDecisionPathLinkFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLink, error) {
	out := new(AutoDispatchDecisionPathLink)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionPathLinkClient) QueryAutoDispatchDecisionPathLinkList(ctx context.Context, in *AutoDispatchDecisionPathLinkFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathLinkList, error) {
	out := new(AutoDispatchDecisionPathLinkList)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutoDispatchDecisionPathLinkServer is the server API for AutoDispatchDecisionPathLink service.
// All implementations must embed UnimplementedAutoDispatchDecisionPathLinkServer
// for forward compatibility
type AutoDispatchDecisionPathLinkServer interface {
	// -----------------------自动化派单决策路径应用表-----------------------
	CreateAutoDispatchDecisionPathLink(context.Context, *AutoDispatchDecisionPathLink) (*AutoDispatchDecisionPathLink, error)
	UpdateAutoDispatchDecisionPathLink(context.Context, *AutoDispatchDecisionPathLink) (*AutoDispatchDecisionPathLink, error)
	QueryAutoDispatchDecisionPathLinkDetail(context.Context, *AutoDispatchDecisionPathLinkFilter) (*AutoDispatchDecisionPathLink, error)
	QueryAutoDispatchDecisionPathLinkList(context.Context, *AutoDispatchDecisionPathLinkFilter) (*AutoDispatchDecisionPathLinkList, error)
	mustEmbedUnimplementedAutoDispatchDecisionPathLinkServer()
}

// UnimplementedAutoDispatchDecisionPathLinkServer must be embedded to have forward compatible implementations.
type UnimplementedAutoDispatchDecisionPathLinkServer struct {
}

func (UnimplementedAutoDispatchDecisionPathLinkServer) CreateAutoDispatchDecisionPathLink(context.Context, *AutoDispatchDecisionPathLink) (*AutoDispatchDecisionPathLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAutoDispatchDecisionPathLink not implemented")
}
func (UnimplementedAutoDispatchDecisionPathLinkServer) UpdateAutoDispatchDecisionPathLink(context.Context, *AutoDispatchDecisionPathLink) (*AutoDispatchDecisionPathLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAutoDispatchDecisionPathLink not implemented")
}
func (UnimplementedAutoDispatchDecisionPathLinkServer) QueryAutoDispatchDecisionPathLinkDetail(context.Context, *AutoDispatchDecisionPathLinkFilter) (*AutoDispatchDecisionPathLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionPathLinkDetail not implemented")
}
func (UnimplementedAutoDispatchDecisionPathLinkServer) QueryAutoDispatchDecisionPathLinkList(context.Context, *AutoDispatchDecisionPathLinkFilter) (*AutoDispatchDecisionPathLinkList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionPathLinkList not implemented")
}
func (UnimplementedAutoDispatchDecisionPathLinkServer) mustEmbedUnimplementedAutoDispatchDecisionPathLinkServer() {
}

// UnsafeAutoDispatchDecisionPathLinkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutoDispatchDecisionPathLinkServer will
// result in compilation errors.
type UnsafeAutoDispatchDecisionPathLinkServer interface {
	mustEmbedUnimplementedAutoDispatchDecisionPathLinkServer()
}

func RegisterAutoDispatchDecisionPathLinkServer(s grpc.ServiceRegistrar, srv AutoDispatchDecisionPathLinkServer) {
	s.RegisterService(&AutoDispatchDecisionPathLink_ServiceDesc, srv)
}

func _AutoDispatchDecisionPathLink_CreateAutoDispatchDecisionPathLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathLink)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathLinkServer).CreateAutoDispatchDecisionPathLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathLink_CreateAutoDispatchDecisionPathLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathLinkServer).CreateAutoDispatchDecisionPathLink(ctx, req.(*AutoDispatchDecisionPathLink))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionPathLink_UpdateAutoDispatchDecisionPathLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathLink)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathLinkServer).UpdateAutoDispatchDecisionPathLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathLink_UpdateAutoDispatchDecisionPathLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathLinkServer).UpdateAutoDispatchDecisionPathLink(ctx, req.(*AutoDispatchDecisionPathLink))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathLinkFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathLinkServer).QueryAutoDispatchDecisionPathLinkDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathLinkServer).QueryAutoDispatchDecisionPathLinkDetail(ctx, req.(*AutoDispatchDecisionPathLinkFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathLinkFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathLinkServer).QueryAutoDispatchDecisionPathLinkList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathLinkServer).QueryAutoDispatchDecisionPathLinkList(ctx, req.(*AutoDispatchDecisionPathLinkFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AutoDispatchDecisionPathLink_ServiceDesc is the grpc.ServiceDesc for AutoDispatchDecisionPathLink service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AutoDispatchDecisionPathLink_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.autoDispatchDecisionPathLink",
	HandlerType: (*AutoDispatchDecisionPathLinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAutoDispatchDecisionPathLink",
			Handler:    _AutoDispatchDecisionPathLink_CreateAutoDispatchDecisionPathLink_Handler,
		},
		{
			MethodName: "UpdateAutoDispatchDecisionPathLink",
			Handler:    _AutoDispatchDecisionPathLink_UpdateAutoDispatchDecisionPathLink_Handler,
		},
		{
			MethodName: "QueryAutoDispatchDecisionPathLinkDetail",
			Handler:    _AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkDetail_Handler,
		},
		{
			MethodName: "QueryAutoDispatchDecisionPathLinkList",
			Handler:    _AutoDispatchDecisionPathLink_QueryAutoDispatchDecisionPathLinkList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AutoDispatchConfigLogNew_CreateAutoDispatchConfigLogNew_FullMethodName      = "/diversion.autoDispatchConfigLogNew/CreateAutoDispatchConfigLogNew"
	AutoDispatchConfigLogNew_UpdateAutoDispatchConfigLogNew_FullMethodName      = "/diversion.autoDispatchConfigLogNew/UpdateAutoDispatchConfigLogNew"
	AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewDetail_FullMethodName = "/diversion.autoDispatchConfigLogNew/QueryAutoDispatchConfigLogNewDetail"
	AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewList_FullMethodName   = "/diversion.autoDispatchConfigLogNew/QueryAutoDispatchConfigLogNewList"
)

// AutoDispatchConfigLogNewClient is the client API for AutoDispatchConfigLogNew service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutoDispatchConfigLogNewClient interface {
	// -----------------------自动派单配置日志表-----------------------
	CreateAutoDispatchConfigLogNew(ctx context.Context, in *AutoDispatchConfigLogNew, opts ...grpc.CallOption) (*AutoDispatchConfigLogNew, error)
	UpdateAutoDispatchConfigLogNew(ctx context.Context, in *AutoDispatchConfigLogNew, opts ...grpc.CallOption) (*AutoDispatchConfigLogNew, error)
	QueryAutoDispatchConfigLogNewDetail(ctx context.Context, in *AutoDispatchConfigLogNewFilter, opts ...grpc.CallOption) (*AutoDispatchConfigLogNew, error)
	QueryAutoDispatchConfigLogNewList(ctx context.Context, in *AutoDispatchConfigLogNewFilter, opts ...grpc.CallOption) (*AutoDispatchConfigLogNewList, error)
}

type autoDispatchConfigLogNewClient struct {
	cc grpc.ClientConnInterface
}

func NewAutoDispatchConfigLogNewClient(cc grpc.ClientConnInterface) AutoDispatchConfigLogNewClient {
	return &autoDispatchConfigLogNewClient{cc}
}

func (c *autoDispatchConfigLogNewClient) CreateAutoDispatchConfigLogNew(ctx context.Context, in *AutoDispatchConfigLogNew, opts ...grpc.CallOption) (*AutoDispatchConfigLogNew, error) {
	out := new(AutoDispatchConfigLogNew)
	err := c.cc.Invoke(ctx, AutoDispatchConfigLogNew_CreateAutoDispatchConfigLogNew_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchConfigLogNewClient) UpdateAutoDispatchConfigLogNew(ctx context.Context, in *AutoDispatchConfigLogNew, opts ...grpc.CallOption) (*AutoDispatchConfigLogNew, error) {
	out := new(AutoDispatchConfigLogNew)
	err := c.cc.Invoke(ctx, AutoDispatchConfigLogNew_UpdateAutoDispatchConfigLogNew_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchConfigLogNewClient) QueryAutoDispatchConfigLogNewDetail(ctx context.Context, in *AutoDispatchConfigLogNewFilter, opts ...grpc.CallOption) (*AutoDispatchConfigLogNew, error) {
	out := new(AutoDispatchConfigLogNew)
	err := c.cc.Invoke(ctx, AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchConfigLogNewClient) QueryAutoDispatchConfigLogNewList(ctx context.Context, in *AutoDispatchConfigLogNewFilter, opts ...grpc.CallOption) (*AutoDispatchConfigLogNewList, error) {
	out := new(AutoDispatchConfigLogNewList)
	err := c.cc.Invoke(ctx, AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutoDispatchConfigLogNewServer is the server API for AutoDispatchConfigLogNew service.
// All implementations must embed UnimplementedAutoDispatchConfigLogNewServer
// for forward compatibility
type AutoDispatchConfigLogNewServer interface {
	// -----------------------自动派单配置日志表-----------------------
	CreateAutoDispatchConfigLogNew(context.Context, *AutoDispatchConfigLogNew) (*AutoDispatchConfigLogNew, error)
	UpdateAutoDispatchConfigLogNew(context.Context, *AutoDispatchConfigLogNew) (*AutoDispatchConfigLogNew, error)
	QueryAutoDispatchConfigLogNewDetail(context.Context, *AutoDispatchConfigLogNewFilter) (*AutoDispatchConfigLogNew, error)
	QueryAutoDispatchConfigLogNewList(context.Context, *AutoDispatchConfigLogNewFilter) (*AutoDispatchConfigLogNewList, error)
	mustEmbedUnimplementedAutoDispatchConfigLogNewServer()
}

// UnimplementedAutoDispatchConfigLogNewServer must be embedded to have forward compatible implementations.
type UnimplementedAutoDispatchConfigLogNewServer struct {
}

func (UnimplementedAutoDispatchConfigLogNewServer) CreateAutoDispatchConfigLogNew(context.Context, *AutoDispatchConfigLogNew) (*AutoDispatchConfigLogNew, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAutoDispatchConfigLogNew not implemented")
}
func (UnimplementedAutoDispatchConfigLogNewServer) UpdateAutoDispatchConfigLogNew(context.Context, *AutoDispatchConfigLogNew) (*AutoDispatchConfigLogNew, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAutoDispatchConfigLogNew not implemented")
}
func (UnimplementedAutoDispatchConfigLogNewServer) QueryAutoDispatchConfigLogNewDetail(context.Context, *AutoDispatchConfigLogNewFilter) (*AutoDispatchConfigLogNew, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchConfigLogNewDetail not implemented")
}
func (UnimplementedAutoDispatchConfigLogNewServer) QueryAutoDispatchConfigLogNewList(context.Context, *AutoDispatchConfigLogNewFilter) (*AutoDispatchConfigLogNewList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchConfigLogNewList not implemented")
}
func (UnimplementedAutoDispatchConfigLogNewServer) mustEmbedUnimplementedAutoDispatchConfigLogNewServer() {
}

// UnsafeAutoDispatchConfigLogNewServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutoDispatchConfigLogNewServer will
// result in compilation errors.
type UnsafeAutoDispatchConfigLogNewServer interface {
	mustEmbedUnimplementedAutoDispatchConfigLogNewServer()
}

func RegisterAutoDispatchConfigLogNewServer(s grpc.ServiceRegistrar, srv AutoDispatchConfigLogNewServer) {
	s.RegisterService(&AutoDispatchConfigLogNew_ServiceDesc, srv)
}

func _AutoDispatchConfigLogNew_CreateAutoDispatchConfigLogNew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchConfigLogNew)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchConfigLogNewServer).CreateAutoDispatchConfigLogNew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchConfigLogNew_CreateAutoDispatchConfigLogNew_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchConfigLogNewServer).CreateAutoDispatchConfigLogNew(ctx, req.(*AutoDispatchConfigLogNew))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchConfigLogNew_UpdateAutoDispatchConfigLogNew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchConfigLogNew)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchConfigLogNewServer).UpdateAutoDispatchConfigLogNew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchConfigLogNew_UpdateAutoDispatchConfigLogNew_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchConfigLogNewServer).UpdateAutoDispatchConfigLogNew(ctx, req.(*AutoDispatchConfigLogNew))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchConfigLogNewFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchConfigLogNewServer).QueryAutoDispatchConfigLogNewDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchConfigLogNewServer).QueryAutoDispatchConfigLogNewDetail(ctx, req.(*AutoDispatchConfigLogNewFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchConfigLogNewFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchConfigLogNewServer).QueryAutoDispatchConfigLogNewList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchConfigLogNewServer).QueryAutoDispatchConfigLogNewList(ctx, req.(*AutoDispatchConfigLogNewFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AutoDispatchConfigLogNew_ServiceDesc is the grpc.ServiceDesc for AutoDispatchConfigLogNew service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AutoDispatchConfigLogNew_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.autoDispatchConfigLogNew",
	HandlerType: (*AutoDispatchConfigLogNewServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAutoDispatchConfigLogNew",
			Handler:    _AutoDispatchConfigLogNew_CreateAutoDispatchConfigLogNew_Handler,
		},
		{
			MethodName: "UpdateAutoDispatchConfigLogNew",
			Handler:    _AutoDispatchConfigLogNew_UpdateAutoDispatchConfigLogNew_Handler,
		},
		{
			MethodName: "QueryAutoDispatchConfigLogNewDetail",
			Handler:    _AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewDetail_Handler,
		},
		{
			MethodName: "QueryAutoDispatchConfigLogNewList",
			Handler:    _AutoDispatchConfigLogNew_QueryAutoDispatchConfigLogNewList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AutoDispatchDecisionRule_CreateAutoDispatchDecisionRule_FullMethodName      = "/diversion.autoDispatchDecisionRule/CreateAutoDispatchDecisionRule"
	AutoDispatchDecisionRule_UpdateAutoDispatchDecisionRule_FullMethodName      = "/diversion.autoDispatchDecisionRule/UpdateAutoDispatchDecisionRule"
	AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleDetail_FullMethodName = "/diversion.autoDispatchDecisionRule/QueryAutoDispatchDecisionRuleDetail"
	AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleList_FullMethodName   = "/diversion.autoDispatchDecisionRule/QueryAutoDispatchDecisionRuleList"
)

// AutoDispatchDecisionRuleClient is the client API for AutoDispatchDecisionRule service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutoDispatchDecisionRuleClient interface {
	// -----------------------自动化派单规则表-----------------------
	CreateAutoDispatchDecisionRule(ctx context.Context, in *AutoDispatchDecisionRule, opts ...grpc.CallOption) (*AutoDispatchDecisionRule, error)
	UpdateAutoDispatchDecisionRule(ctx context.Context, in *AutoDispatchDecisionRule, opts ...grpc.CallOption) (*AutoDispatchDecisionRule, error)
	QueryAutoDispatchDecisionRuleDetail(ctx context.Context, in *AutoDispatchDecisionRuleFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionRule, error)
	QueryAutoDispatchDecisionRuleList(ctx context.Context, in *AutoDispatchDecisionRuleFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionRuleList, error)
}

type autoDispatchDecisionRuleClient struct {
	cc grpc.ClientConnInterface
}

func NewAutoDispatchDecisionRuleClient(cc grpc.ClientConnInterface) AutoDispatchDecisionRuleClient {
	return &autoDispatchDecisionRuleClient{cc}
}

func (c *autoDispatchDecisionRuleClient) CreateAutoDispatchDecisionRule(ctx context.Context, in *AutoDispatchDecisionRule, opts ...grpc.CallOption) (*AutoDispatchDecisionRule, error) {
	out := new(AutoDispatchDecisionRule)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionRule_CreateAutoDispatchDecisionRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionRuleClient) UpdateAutoDispatchDecisionRule(ctx context.Context, in *AutoDispatchDecisionRule, opts ...grpc.CallOption) (*AutoDispatchDecisionRule, error) {
	out := new(AutoDispatchDecisionRule)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionRule_UpdateAutoDispatchDecisionRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionRuleClient) QueryAutoDispatchDecisionRuleDetail(ctx context.Context, in *AutoDispatchDecisionRuleFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionRule, error) {
	out := new(AutoDispatchDecisionRule)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionRuleClient) QueryAutoDispatchDecisionRuleList(ctx context.Context, in *AutoDispatchDecisionRuleFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionRuleList, error) {
	out := new(AutoDispatchDecisionRuleList)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutoDispatchDecisionRuleServer is the server API for AutoDispatchDecisionRule service.
// All implementations must embed UnimplementedAutoDispatchDecisionRuleServer
// for forward compatibility
type AutoDispatchDecisionRuleServer interface {
	// -----------------------自动化派单规则表-----------------------
	CreateAutoDispatchDecisionRule(context.Context, *AutoDispatchDecisionRule) (*AutoDispatchDecisionRule, error)
	UpdateAutoDispatchDecisionRule(context.Context, *AutoDispatchDecisionRule) (*AutoDispatchDecisionRule, error)
	QueryAutoDispatchDecisionRuleDetail(context.Context, *AutoDispatchDecisionRuleFilter) (*AutoDispatchDecisionRule, error)
	QueryAutoDispatchDecisionRuleList(context.Context, *AutoDispatchDecisionRuleFilter) (*AutoDispatchDecisionRuleList, error)
	mustEmbedUnimplementedAutoDispatchDecisionRuleServer()
}

// UnimplementedAutoDispatchDecisionRuleServer must be embedded to have forward compatible implementations.
type UnimplementedAutoDispatchDecisionRuleServer struct {
}

func (UnimplementedAutoDispatchDecisionRuleServer) CreateAutoDispatchDecisionRule(context.Context, *AutoDispatchDecisionRule) (*AutoDispatchDecisionRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAutoDispatchDecisionRule not implemented")
}
func (UnimplementedAutoDispatchDecisionRuleServer) UpdateAutoDispatchDecisionRule(context.Context, *AutoDispatchDecisionRule) (*AutoDispatchDecisionRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAutoDispatchDecisionRule not implemented")
}
func (UnimplementedAutoDispatchDecisionRuleServer) QueryAutoDispatchDecisionRuleDetail(context.Context, *AutoDispatchDecisionRuleFilter) (*AutoDispatchDecisionRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionRuleDetail not implemented")
}
func (UnimplementedAutoDispatchDecisionRuleServer) QueryAutoDispatchDecisionRuleList(context.Context, *AutoDispatchDecisionRuleFilter) (*AutoDispatchDecisionRuleList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionRuleList not implemented")
}
func (UnimplementedAutoDispatchDecisionRuleServer) mustEmbedUnimplementedAutoDispatchDecisionRuleServer() {
}

// UnsafeAutoDispatchDecisionRuleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutoDispatchDecisionRuleServer will
// result in compilation errors.
type UnsafeAutoDispatchDecisionRuleServer interface {
	mustEmbedUnimplementedAutoDispatchDecisionRuleServer()
}

func RegisterAutoDispatchDecisionRuleServer(s grpc.ServiceRegistrar, srv AutoDispatchDecisionRuleServer) {
	s.RegisterService(&AutoDispatchDecisionRule_ServiceDesc, srv)
}

func _AutoDispatchDecisionRule_CreateAutoDispatchDecisionRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionRule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionRuleServer).CreateAutoDispatchDecisionRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionRule_CreateAutoDispatchDecisionRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionRuleServer).CreateAutoDispatchDecisionRule(ctx, req.(*AutoDispatchDecisionRule))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionRule_UpdateAutoDispatchDecisionRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionRule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionRuleServer).UpdateAutoDispatchDecisionRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionRule_UpdateAutoDispatchDecisionRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionRuleServer).UpdateAutoDispatchDecisionRule(ctx, req.(*AutoDispatchDecisionRule))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionRuleFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionRuleServer).QueryAutoDispatchDecisionRuleDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionRuleServer).QueryAutoDispatchDecisionRuleDetail(ctx, req.(*AutoDispatchDecisionRuleFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionRuleFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionRuleServer).QueryAutoDispatchDecisionRuleList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionRuleServer).QueryAutoDispatchDecisionRuleList(ctx, req.(*AutoDispatchDecisionRuleFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AutoDispatchDecisionRule_ServiceDesc is the grpc.ServiceDesc for AutoDispatchDecisionRule service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AutoDispatchDecisionRule_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.autoDispatchDecisionRule",
	HandlerType: (*AutoDispatchDecisionRuleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAutoDispatchDecisionRule",
			Handler:    _AutoDispatchDecisionRule_CreateAutoDispatchDecisionRule_Handler,
		},
		{
			MethodName: "UpdateAutoDispatchDecisionRule",
			Handler:    _AutoDispatchDecisionRule_UpdateAutoDispatchDecisionRule_Handler,
		},
		{
			MethodName: "QueryAutoDispatchDecisionRuleDetail",
			Handler:    _AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleDetail_Handler,
		},
		{
			MethodName: "QueryAutoDispatchDecisionRuleList",
			Handler:    _AutoDispatchDecisionRule_QueryAutoDispatchDecisionRuleList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	AutoDispatchDecisionPathOrder_CreateAutoDispatchDecisionPathOrder_FullMethodName      = "/diversion.autoDispatchDecisionPathOrder/CreateAutoDispatchDecisionPathOrder"
	AutoDispatchDecisionPathOrder_UpdateAutoDispatchDecisionPathOrder_FullMethodName      = "/diversion.autoDispatchDecisionPathOrder/UpdateAutoDispatchDecisionPathOrder"
	AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderDetail_FullMethodName = "/diversion.autoDispatchDecisionPathOrder/QueryAutoDispatchDecisionPathOrderDetail"
	AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderList_FullMethodName   = "/diversion.autoDispatchDecisionPathOrder/QueryAutoDispatchDecisionPathOrderList"
)

// AutoDispatchDecisionPathOrderClient is the client API for AutoDispatchDecisionPathOrder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutoDispatchDecisionPathOrderClient interface {
	// -----------------------自动化派单决策路径订单表-----------------------
	CreateAutoDispatchDecisionPathOrder(ctx context.Context, in *AutoDispatchDecisionPathOrder, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrder, error)
	UpdateAutoDispatchDecisionPathOrder(ctx context.Context, in *AutoDispatchDecisionPathOrder, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrder, error)
	QueryAutoDispatchDecisionPathOrderDetail(ctx context.Context, in *AutoDispatchDecisionPathOrderFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrder, error)
	QueryAutoDispatchDecisionPathOrderList(ctx context.Context, in *AutoDispatchDecisionPathOrderFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrderList, error)
}

type autoDispatchDecisionPathOrderClient struct {
	cc grpc.ClientConnInterface
}

func NewAutoDispatchDecisionPathOrderClient(cc grpc.ClientConnInterface) AutoDispatchDecisionPathOrderClient {
	return &autoDispatchDecisionPathOrderClient{cc}
}

func (c *autoDispatchDecisionPathOrderClient) CreateAutoDispatchDecisionPathOrder(ctx context.Context, in *AutoDispatchDecisionPathOrder, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrder, error) {
	out := new(AutoDispatchDecisionPathOrder)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathOrder_CreateAutoDispatchDecisionPathOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionPathOrderClient) UpdateAutoDispatchDecisionPathOrder(ctx context.Context, in *AutoDispatchDecisionPathOrder, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrder, error) {
	out := new(AutoDispatchDecisionPathOrder)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathOrder_UpdateAutoDispatchDecisionPathOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionPathOrderClient) QueryAutoDispatchDecisionPathOrderDetail(ctx context.Context, in *AutoDispatchDecisionPathOrderFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrder, error) {
	out := new(AutoDispatchDecisionPathOrder)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDispatchDecisionPathOrderClient) QueryAutoDispatchDecisionPathOrderList(ctx context.Context, in *AutoDispatchDecisionPathOrderFilter, opts ...grpc.CallOption) (*AutoDispatchDecisionPathOrderList, error) {
	out := new(AutoDispatchDecisionPathOrderList)
	err := c.cc.Invoke(ctx, AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutoDispatchDecisionPathOrderServer is the server API for AutoDispatchDecisionPathOrder service.
// All implementations must embed UnimplementedAutoDispatchDecisionPathOrderServer
// for forward compatibility
type AutoDispatchDecisionPathOrderServer interface {
	// -----------------------自动化派单决策路径订单表-----------------------
	CreateAutoDispatchDecisionPathOrder(context.Context, *AutoDispatchDecisionPathOrder) (*AutoDispatchDecisionPathOrder, error)
	UpdateAutoDispatchDecisionPathOrder(context.Context, *AutoDispatchDecisionPathOrder) (*AutoDispatchDecisionPathOrder, error)
	QueryAutoDispatchDecisionPathOrderDetail(context.Context, *AutoDispatchDecisionPathOrderFilter) (*AutoDispatchDecisionPathOrder, error)
	QueryAutoDispatchDecisionPathOrderList(context.Context, *AutoDispatchDecisionPathOrderFilter) (*AutoDispatchDecisionPathOrderList, error)
	mustEmbedUnimplementedAutoDispatchDecisionPathOrderServer()
}

// UnimplementedAutoDispatchDecisionPathOrderServer must be embedded to have forward compatible implementations.
type UnimplementedAutoDispatchDecisionPathOrderServer struct {
}

func (UnimplementedAutoDispatchDecisionPathOrderServer) CreateAutoDispatchDecisionPathOrder(context.Context, *AutoDispatchDecisionPathOrder) (*AutoDispatchDecisionPathOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAutoDispatchDecisionPathOrder not implemented")
}
func (UnimplementedAutoDispatchDecisionPathOrderServer) UpdateAutoDispatchDecisionPathOrder(context.Context, *AutoDispatchDecisionPathOrder) (*AutoDispatchDecisionPathOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAutoDispatchDecisionPathOrder not implemented")
}
func (UnimplementedAutoDispatchDecisionPathOrderServer) QueryAutoDispatchDecisionPathOrderDetail(context.Context, *AutoDispatchDecisionPathOrderFilter) (*AutoDispatchDecisionPathOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionPathOrderDetail not implemented")
}
func (UnimplementedAutoDispatchDecisionPathOrderServer) QueryAutoDispatchDecisionPathOrderList(context.Context, *AutoDispatchDecisionPathOrderFilter) (*AutoDispatchDecisionPathOrderList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAutoDispatchDecisionPathOrderList not implemented")
}
func (UnimplementedAutoDispatchDecisionPathOrderServer) mustEmbedUnimplementedAutoDispatchDecisionPathOrderServer() {
}

// UnsafeAutoDispatchDecisionPathOrderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutoDispatchDecisionPathOrderServer will
// result in compilation errors.
type UnsafeAutoDispatchDecisionPathOrderServer interface {
	mustEmbedUnimplementedAutoDispatchDecisionPathOrderServer()
}

func RegisterAutoDispatchDecisionPathOrderServer(s grpc.ServiceRegistrar, srv AutoDispatchDecisionPathOrderServer) {
	s.RegisterService(&AutoDispatchDecisionPathOrder_ServiceDesc, srv)
}

func _AutoDispatchDecisionPathOrder_CreateAutoDispatchDecisionPathOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathOrderServer).CreateAutoDispatchDecisionPathOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathOrder_CreateAutoDispatchDecisionPathOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathOrderServer).CreateAutoDispatchDecisionPathOrder(ctx, req.(*AutoDispatchDecisionPathOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionPathOrder_UpdateAutoDispatchDecisionPathOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathOrderServer).UpdateAutoDispatchDecisionPathOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathOrder_UpdateAutoDispatchDecisionPathOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathOrderServer).UpdateAutoDispatchDecisionPathOrder(ctx, req.(*AutoDispatchDecisionPathOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathOrderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathOrderServer).QueryAutoDispatchDecisionPathOrderDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathOrderServer).QueryAutoDispatchDecisionPathOrderDetail(ctx, req.(*AutoDispatchDecisionPathOrderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoDispatchDecisionPathOrderFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDispatchDecisionPathOrderServer).QueryAutoDispatchDecisionPathOrderList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDispatchDecisionPathOrderServer).QueryAutoDispatchDecisionPathOrderList(ctx, req.(*AutoDispatchDecisionPathOrderFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// AutoDispatchDecisionPathOrder_ServiceDesc is the grpc.ServiceDesc for AutoDispatchDecisionPathOrder service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AutoDispatchDecisionPathOrder_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.autoDispatchDecisionPathOrder",
	HandlerType: (*AutoDispatchDecisionPathOrderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAutoDispatchDecisionPathOrder",
			Handler:    _AutoDispatchDecisionPathOrder_CreateAutoDispatchDecisionPathOrder_Handler,
		},
		{
			MethodName: "UpdateAutoDispatchDecisionPathOrder",
			Handler:    _AutoDispatchDecisionPathOrder_UpdateAutoDispatchDecisionPathOrder_Handler,
		},
		{
			MethodName: "QueryAutoDispatchDecisionPathOrderDetail",
			Handler:    _AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderDetail_Handler,
		},
		{
			MethodName: "QueryAutoDispatchDecisionPathOrderList",
			Handler:    _AutoDispatchDecisionPathOrder_QueryAutoDispatchDecisionPathOrderList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}

const (
	DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewDetail_FullMethodName = "/diversion.dwdDistributeValidOrderView/QueryDwdDistributeValidOrderViewDetail"
	DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewList_FullMethodName   = "/diversion.dwdDistributeValidOrderView/QueryDwdDistributeValidOrderViewList"
)

// DwdDistributeValidOrderViewClient is the client API for DwdDistributeValidOrderView service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DwdDistributeValidOrderViewClient interface {
	// -----------------------dwdDistributeValidOrderView-----------------------
	QueryDwdDistributeValidOrderViewDetail(ctx context.Context, in *DwdDistributeValidOrderViewFilter, opts ...grpc.CallOption) (*DwdDistributeValidOrderView, error)
	QueryDwdDistributeValidOrderViewList(ctx context.Context, in *DwdDistributeValidOrderViewFilter, opts ...grpc.CallOption) (*DwdDistributeValidOrderViewList, error)
}

type dwdDistributeValidOrderViewClient struct {
	cc grpc.ClientConnInterface
}

func NewDwdDistributeValidOrderViewClient(cc grpc.ClientConnInterface) DwdDistributeValidOrderViewClient {
	return &dwdDistributeValidOrderViewClient{cc}
}

func (c *dwdDistributeValidOrderViewClient) QueryDwdDistributeValidOrderViewDetail(ctx context.Context, in *DwdDistributeValidOrderViewFilter, opts ...grpc.CallOption) (*DwdDistributeValidOrderView, error) {
	out := new(DwdDistributeValidOrderView)
	err := c.cc.Invoke(ctx, DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dwdDistributeValidOrderViewClient) QueryDwdDistributeValidOrderViewList(ctx context.Context, in *DwdDistributeValidOrderViewFilter, opts ...grpc.CallOption) (*DwdDistributeValidOrderViewList, error) {
	out := new(DwdDistributeValidOrderViewList)
	err := c.cc.Invoke(ctx, DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DwdDistributeValidOrderViewServer is the server API for DwdDistributeValidOrderView service.
// All implementations must embed UnimplementedDwdDistributeValidOrderViewServer
// for forward compatibility
type DwdDistributeValidOrderViewServer interface {
	// -----------------------dwdDistributeValidOrderView-----------------------
	QueryDwdDistributeValidOrderViewDetail(context.Context, *DwdDistributeValidOrderViewFilter) (*DwdDistributeValidOrderView, error)
	QueryDwdDistributeValidOrderViewList(context.Context, *DwdDistributeValidOrderViewFilter) (*DwdDistributeValidOrderViewList, error)
	mustEmbedUnimplementedDwdDistributeValidOrderViewServer()
}

// UnimplementedDwdDistributeValidOrderViewServer must be embedded to have forward compatible implementations.
type UnimplementedDwdDistributeValidOrderViewServer struct {
}

func (UnimplementedDwdDistributeValidOrderViewServer) QueryDwdDistributeValidOrderViewDetail(context.Context, *DwdDistributeValidOrderViewFilter) (*DwdDistributeValidOrderView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDwdDistributeValidOrderViewDetail not implemented")
}
func (UnimplementedDwdDistributeValidOrderViewServer) QueryDwdDistributeValidOrderViewList(context.Context, *DwdDistributeValidOrderViewFilter) (*DwdDistributeValidOrderViewList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDwdDistributeValidOrderViewList not implemented")
}
func (UnimplementedDwdDistributeValidOrderViewServer) mustEmbedUnimplementedDwdDistributeValidOrderViewServer() {
}

// UnsafeDwdDistributeValidOrderViewServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DwdDistributeValidOrderViewServer will
// result in compilation errors.
type UnsafeDwdDistributeValidOrderViewServer interface {
	mustEmbedUnimplementedDwdDistributeValidOrderViewServer()
}

func RegisterDwdDistributeValidOrderViewServer(s grpc.ServiceRegistrar, srv DwdDistributeValidOrderViewServer) {
	s.RegisterService(&DwdDistributeValidOrderView_ServiceDesc, srv)
}

func _DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DwdDistributeValidOrderViewFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DwdDistributeValidOrderViewServer).QueryDwdDistributeValidOrderViewDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DwdDistributeValidOrderViewServer).QueryDwdDistributeValidOrderViewDetail(ctx, req.(*DwdDistributeValidOrderViewFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DwdDistributeValidOrderViewFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DwdDistributeValidOrderViewServer).QueryDwdDistributeValidOrderViewList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DwdDistributeValidOrderViewServer).QueryDwdDistributeValidOrderViewList(ctx, req.(*DwdDistributeValidOrderViewFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// DwdDistributeValidOrderView_ServiceDesc is the grpc.ServiceDesc for DwdDistributeValidOrderView service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DwdDistributeValidOrderView_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "diversion.dwdDistributeValidOrderView",
	HandlerType: (*DwdDistributeValidOrderViewServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryDwdDistributeValidOrderViewDetail",
			Handler:    _DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewDetail_Handler,
		},
		{
			MethodName: "QueryDwdDistributeValidOrderViewList",
			Handler:    _DwdDistributeValidOrderView_QueryDwdDistributeValidOrderViewList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/go_service/diversion/diversion.proto",
}
